CCS PCM C Compiler, Version 4.057, 32216               15-abr-14 22:59

               Filename: C:\Users\Core\Dropbox\Codigo_ccsc\Ejemplos\1_Temperatura(MCP9700)\1_Temperatura_MCP9700.lst

               ROM used: 3048 words (37%)
                         Largest free fragment is 2048
               RAM used: 128 (35%) at main() level
                         159 (43%) worst case
               Stack:    4 worst case (2 in main + 2 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   218
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   0CD
.................... /* ---------------------------------------------- 
.................... * Proyecto de la Comunidad SpainLabs - SL Air Mote 
.................... * Web Oficial: www.spainlabs.com 
.................... * Foro de desarrollo: http://www.spainlabs.com/foro/viewforum.php?f=44 
.................... * 
.................... * Titulo: 01 Ejemplo sensor de Temperatura MCP9700 
.................... * 
.................... * Descripcion: Ejemplo de medida del sensor de temperatura MCP9700 de Microchip. 
.................... * El mote realiza la medida de la temperatura y envia al master la informacion 
.................... * usando el frame. 
.................... * 
.................... * Hardware: Air v1.0 rev A 
.................... * Web version Hardware: http://www.spainlabs.com/foro/viewtopic.php?f=44&t=1337 
.................... * Dispositivo: Air v1.0 rev A configurado como mote. 
.................... * 
.................... * Version: 001 
.................... * Fecha: 15/0/14 
.................... * Autor: Grafisoft 
....................  ----------------------------------------------- 
....................  */ 
....................   
.................... #include <16F876A.h> 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #device ADC = 10     // ADC configurado a 10 bits. 
.................... #FUSES NOWDT, XT, PUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=4000000) 
*
02F3:  MOVLW  C2
02F4:  MOVWF  04
02F5:  BCF    03.7
02F6:  MOVF   00,W
02F7:  BTFSC  03.2
02F8:  GOTO   307
02F9:  MOVLW  01
02FA:  MOVWF  78
02FB:  CLRF   77
02FC:  DECFSZ 77,F
02FD:  GOTO   2FC
02FE:  DECFSZ 78,F
02FF:  GOTO   2FB
0300:  MOVLW  4A
0301:  MOVWF  77
0302:  DECFSZ 77,F
0303:  GOTO   302
0304:  GOTO   305
0305:  DECFSZ 00,F
0306:  GOTO   2F9
0307:  RETLW  00
....................  
.................... // Libreria modulo comunicacion NRF24L01+ 
.................... #include "lib_rf2gh4_10.h" 
.................... //******************************************************************************** 
.................... //*    lib_rf2gh4_10.h                                                           * 
.................... //*     version: 1.0                                                             * 
.................... //*     Esta librería contiene las funciones necesarias para gestionar el módulo * 
.................... //*    RF2GH4 con programas del compilador CCS                                   * 
.................... //*    Copyright (C) 2007  Bizintek Innova S.L.                                  * 
.................... //******************************************************************************** 
.................... //*    This program is free software; you can redistribute it and/or modify      * 
.................... //*    it under the terms of the GNU General Public License as published by      * 
.................... //*    the Free Software Foundation; either version 2 of the License, or         * 
.................... //*    (at your option) any later version.                                       * 
.................... //*                                                                              * 
.................... //*    This program is distributed in the hope that it will be useful,           * 
.................... //*    but WITHOUT ANY WARRANTY; without even the implied warranty of            * 
.................... //*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             * 
.................... //*    GNU General Public License for more details.                              * 
.................... //*                                                                              * 
.................... //*    You should have received a copy of the GNU General Public License along   * 
.................... //*    with this program; if not, write to the Free Software Foundation, Inc.,   * 
.................... //*    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               * 
.................... //******************************************************************************** 
....................  
....................  
.................... //******************** 
.................... //*   DEFINICIONES   * 
.................... //******************** 
....................  
.................... // PORTB 
.................... #define RF_IRQ        PIN_B0 
.................... #define RF_IRQ_TRIS   TRISB,0 
....................  
.................... // PORTC 
.................... #define   RF_CS       PIN_C1 
.................... #define   RF_CE       PIN_C2 
.................... #define   SCK         PIN_C3 
.................... #define   SDI         PIN_C4 
.................... #define   SDO         PIN_C5 
....................                        
.................... #define   RF_CS_TRIS  TRISC,1 
.................... #define   RF_CE_TRIS  TRISC,2 
.................... #define   SCK_TRIS    TRISC,3 
.................... #define   SDI_TRIS    TRISC,4 
.................... #define   SDO_TRIS    TRISC,5 
....................  
....................  
....................  
.................... //***************** 
.................... //*   VARIABLES   * 
.................... //***************** 
.................... #BYTE TRISA     =  0x85 
.................... #BYTE TRISB     =  0x86 
.................... #BYTE TRISC     =  0x87 
.................... #BYTE INTCON    =  0x0B 
....................  
.................... //Variables internas 
.................... static int1        interRF; 
*
0A23:  BCF    03.5
0A24:  BCF    28.0
.................... static int16       noRF; 
0A25:  CLRF   29
0A26:  CLRF   2A
.................... static int1        RCVNW=0; 
0A27:  BCF    28.1
.................... static int8        DATA_N_SND=0; 
0A28:  CLRF   2B
.................... static int8        DATA_N_RCV=0; 
0A29:  CLRF   2C
....................  
.................... //Variables configurables 
.................... static int8        RF_DATA[8]; 
0A2A:  CLRF   2D
0A2B:  CLRF   2E
0A2C:  CLRF   2F
0A2D:  CLRF   30
0A2E:  CLRF   31
0A2F:  CLRF   32
0A30:  CLRF   33
0A31:  CLRF   34
.................... static int8        RF_DIR; 
0A32:  CLRF   35
....................  
....................  
.................... //************** 
.................... //*   CÓDIGO   * 
.................... //************** 
....................  
.................... //***************************************************** 
.................... //*               RF_CONFIG_SPI()                     * 
.................... //***************************************************** 
.................... //*Descripción: La función configura el módulo SPI del* 
.................... //*microcontrolador.En ella se especifica como salida * 
.................... //*SDO y como entrada SDI entre otros parámetros del  * 
.................... //*protocolo SPI.                                     * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_CONFIG_SPI() 
.................... { 
....................    //Configuración I/O. 
....................    bit_clear(SCK_TRIS); 
*
0104:  BSF    03.5
0105:  BCF    07.3
....................    bit_set(SDI_TRIS); 
0106:  BSF    07.4
....................    bit_clear(SDO_TRIS); 
0107:  BCF    07.5
....................  
....................    //Configuración módulo comunicaciones. 
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_XMIT_L_TO_H 
....................    |SPI_CLK_DIV_4|SPI_SAMPLE_AT_END); 
0108:  BCF    03.5
0109:  BCF    14.5
010A:  BCF    36.5
010B:  MOVF   36,W
010C:  BSF    03.5
010D:  MOVWF  07
010E:  BCF    03.5
010F:  BSF    36.4
0110:  MOVF   36,W
0111:  BSF    03.5
0112:  MOVWF  07
0113:  BCF    03.5
0114:  BCF    36.3
0115:  MOVF   36,W
0116:  BSF    03.5
0117:  MOVWF  07
0118:  MOVLW  20
0119:  BCF    03.5
011A:  MOVWF  14
011B:  MOVLW  C0
011C:  BSF    03.5
011D:  MOVWF  14
*
0A33:  MOVLW  FF
0A34:  MOVWF  36
.................... } 
*
011E:  BCF    03.5
011F:  BSF    0A.3
0120:  BCF    0A.4
0121:  GOTO   281 (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                    RF_INT_EN()                    * 
.................... //***************************************************** 
.................... //*Descripción:Se encarga de habilitar la interrupción* 
.................... //*externa (RB0) utilizada por el módulo de RF en la  * 
.................... //*recepción de datos.                                * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_INT_EN() 
.................... { 
....................    //Habilitar interrupciones externas con flanco de 
....................    //bajada. 
....................    disable_interrupts(global); 
*
00F6:  BCF    0B.6
00F7:  BCF    0B.7
00F8:  BTFSC  0B.7
00F9:  GOTO   0F7
....................    enable_interrupts(int_ext); 
00FA:  BSF    0B.4
....................    ext_int_edge( H_TO_L ); 
00FB:  BSF    03.5
00FC:  BCF    01.6
....................    bit_set(RF_IRQ_TRIS); 
00FD:  BSF    06.0
....................    enable_interrupts(global); 
00FE:  MOVLW  C0
00FF:  BCF    03.5
0100:  IORWF  0B,F
.................... } 
0101:  BSF    0A.3
0102:  BCF    0A.4
0103:  GOTO   27E (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*        RF_CONFIG(int canal, int dir)              * 
.................... //***************************************************** 
.................... //*Descripción:Esta función se encarga de configurar  * 
.................... //*el transceptor habilitando su propia dirección de  * 
.................... //*escucha y el canal entre otros parámetros.         * 
.................... //***************************************************** 
.................... //*Variables de entrada:- Canal                       * 
.................... //*                     - Direccion                   * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_CONFIG(int canal, int dir) 
.................... { 
....................  
....................    bit_clear(RF_CS_TRIS); 
*
0122:  BSF    03.5
0123:  BCF    07.1
....................    bit_set(RF_IRQ_TRIS); 
0124:  BSF    06.0
....................    bit_clear(RF_CE_TRIS); 
0125:  BCF    07.2
....................  
....................    output_low(RF_CE); 
0126:  BCF    03.5
0127:  BCF    36.2
0128:  MOVF   36,W
0129:  BSF    03.5
012A:  MOVWF  07
012B:  BCF    03.5
012C:  BCF    07.2
....................  
....................    // TX_ADDR (0xFF) 
....................    //Configuración de la dirección de envio aleatoria. 
....................    //En la función de enviar se configura la direccion 
....................    //deseada por el usuario. 
....................    output_low(RF_CS); 
012D:  BCF    36.1
012E:  MOVF   36,W
012F:  BSF    03.5
0130:  MOVWF  07
0131:  BCF    03.5
0132:  BCF    07.1
....................    spi_write(0x30); 
0133:  MOVF   13,W
0134:  MOVLW  30
0135:  MOVWF  13
0136:  BSF    03.5
0137:  BTFSS  14.0
0138:  GOTO   137
....................    spi_write(0xFF); 
0139:  BCF    03.5
013A:  MOVF   13,W
013B:  MOVLW  FF
013C:  MOVWF  13
013D:  BSF    03.5
013E:  BTFSS  14.0
013F:  GOTO   13E
....................    spi_write(0xC2); 
0140:  BCF    03.5
0141:  MOVF   13,W
0142:  MOVLW  C2
0143:  MOVWF  13
0144:  BSF    03.5
0145:  BTFSS  14.0
0146:  GOTO   145
....................    spi_write(0xC2); 
0147:  BCF    03.5
0148:  MOVF   13,W
0149:  MOVLW  C2
014A:  MOVWF  13
014B:  BSF    03.5
014C:  BTFSS  14.0
014D:  GOTO   14C
....................    spi_write(0xC2); 
014E:  BCF    03.5
014F:  MOVF   13,W
0150:  MOVLW  C2
0151:  MOVWF  13
0152:  BSF    03.5
0153:  BTFSS  14.0
0154:  GOTO   153
....................    spi_write(0xC2); 
0155:  BCF    03.5
0156:  MOVF   13,W
0157:  MOVLW  C2
0158:  MOVWF  13
0159:  BSF    03.5
015A:  BTFSS  14.0
015B:  GOTO   15A
....................    output_high(RF_CS); 
015C:  BCF    03.5
015D:  BCF    36.1
015E:  MOVF   36,W
015F:  BSF    03.5
0160:  MOVWF  07
0161:  BCF    03.5
0162:  BSF    07.1
....................  
....................    // RX_ADDR_P0 (0xFF) ACK 
....................    //Configuración de la direccióndel Pipe0 para la 
....................    //recepción de ACK. 
....................    output_low(RF_CS); 
0163:  BCF    36.1
0164:  MOVF   36,W
0165:  BSF    03.5
0166:  MOVWF  07
0167:  BCF    03.5
0168:  BCF    07.1
....................    spi_write(0x2A); 
0169:  MOVF   13,W
016A:  MOVLW  2A
016B:  MOVWF  13
016C:  BSF    03.5
016D:  BTFSS  14.0
016E:  GOTO   16D
....................    spi_write(0xFF); 
016F:  BCF    03.5
0170:  MOVF   13,W
0171:  MOVLW  FF
0172:  MOVWF  13
0173:  BSF    03.5
0174:  BTFSS  14.0
0175:  GOTO   174
....................    spi_write(0xC2); 
0176:  BCF    03.5
0177:  MOVF   13,W
0178:  MOVLW  C2
0179:  MOVWF  13
017A:  BSF    03.5
017B:  BTFSS  14.0
017C:  GOTO   17B
....................    spi_write(0xC2); 
017D:  BCF    03.5
017E:  MOVF   13,W
017F:  MOVLW  C2
0180:  MOVWF  13
0181:  BSF    03.5
0182:  BTFSS  14.0
0183:  GOTO   182
....................    spi_write(0xC2); 
0184:  BCF    03.5
0185:  MOVF   13,W
0186:  MOVLW  C2
0187:  MOVWF  13
0188:  BSF    03.5
0189:  BTFSS  14.0
018A:  GOTO   189
....................    spi_write(0xC2); 
018B:  BCF    03.5
018C:  MOVF   13,W
018D:  MOVLW  C2
018E:  MOVWF  13
018F:  BSF    03.5
0190:  BTFSS  14.0
0191:  GOTO   190
....................    output_high(RF_CS); 
0192:  BCF    03.5
0193:  BCF    36.1
0194:  MOVF   36,W
0195:  BSF    03.5
0196:  MOVWF  07
0197:  BCF    03.5
0198:  BSF    07.1
....................  
....................    // RX_ADDR_P1 (dir) 
....................    //Configuración de la direccióndel Pipe1 para la 
....................    //recepción de tramas. 
....................    output_low(RF_CS); 
0199:  BCF    36.1
019A:  MOVF   36,W
019B:  BSF    03.5
019C:  MOVWF  07
019D:  BCF    03.5
019E:  BCF    07.1
....................    spi_write(0x2B); 
019F:  MOVF   13,W
01A0:  MOVLW  2B
01A1:  MOVWF  13
01A2:  BSF    03.5
01A3:  BTFSS  14.0
01A4:  GOTO   1A3
....................    spi_write(dir); 
01A5:  BCF    03.5
01A6:  MOVF   13,W
01A7:  BSF    03.5
01A8:  MOVF   42,W
01A9:  BCF    03.5
01AA:  MOVWF  13
01AB:  BSF    03.5
01AC:  BTFSS  14.0
01AD:  GOTO   1AC
....................    spi_write(0xC2); 
01AE:  BCF    03.5
01AF:  MOVF   13,W
01B0:  MOVLW  C2
01B1:  MOVWF  13
01B2:  BSF    03.5
01B3:  BTFSS  14.0
01B4:  GOTO   1B3
....................    spi_write(0xC2); 
01B5:  BCF    03.5
01B6:  MOVF   13,W
01B7:  MOVLW  C2
01B8:  MOVWF  13
01B9:  BSF    03.5
01BA:  BTFSS  14.0
01BB:  GOTO   1BA
....................    spi_write(0xC2); 
01BC:  BCF    03.5
01BD:  MOVF   13,W
01BE:  MOVLW  C2
01BF:  MOVWF  13
01C0:  BSF    03.5
01C1:  BTFSS  14.0
01C2:  GOTO   1C1
....................    spi_write(0xC2); 
01C3:  BCF    03.5
01C4:  MOVF   13,W
01C5:  MOVLW  C2
01C6:  MOVWF  13
01C7:  BSF    03.5
01C8:  BTFSS  14.0
01C9:  GOTO   1C8
....................    output_high(RF_CS); 
01CA:  BCF    03.5
01CB:  BCF    36.1
01CC:  MOVF   36,W
01CD:  BSF    03.5
01CE:  MOVWF  07
01CF:  BCF    03.5
01D0:  BSF    07.1
....................  
....................    // RX_ADDR_P2 (0x00) BROADCAST 
....................    //Configuración de la direccióndel Pipe2 para la 
....................    //recepción de tramas 
....................    output_low(RF_CS); 
01D1:  BCF    36.1
01D2:  MOVF   36,W
01D3:  BSF    03.5
01D4:  MOVWF  07
01D5:  BCF    03.5
01D6:  BCF    07.1
....................    spi_write(0x2C); 
01D7:  MOVF   13,W
01D8:  MOVLW  2C
01D9:  MOVWF  13
01DA:  BSF    03.5
01DB:  BTFSS  14.0
01DC:  GOTO   1DB
....................    spi_write(0x00); 
01DD:  BCF    03.5
01DE:  MOVF   13,W
01DF:  CLRF   13
01E0:  BSF    03.5
01E1:  BTFSS  14.0
01E2:  GOTO   1E1
....................    output_high(RF_CS); 
01E3:  BCF    03.5
01E4:  BCF    36.1
01E5:  MOVF   36,W
01E6:  BSF    03.5
01E7:  MOVWF  07
01E8:  BCF    03.5
01E9:  BSF    07.1
....................  
....................    // EN_AA 
....................    //Habilitar AutoAck en los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
01EA:  BCF    36.1
01EB:  MOVF   36,W
01EC:  BSF    03.5
01ED:  MOVWF  07
01EE:  BCF    03.5
01EF:  BCF    07.1
....................    spi_write(0x21); 
01F0:  MOVF   13,W
01F1:  MOVLW  21
01F2:  MOVWF  13
01F3:  BSF    03.5
01F4:  BTFSS  14.0
01F5:  GOTO   1F4
....................    spi_write(0x07); 
01F6:  BCF    03.5
01F7:  MOVF   13,W
01F8:  MOVLW  07
01F9:  MOVWF  13
01FA:  BSF    03.5
01FB:  BTFSS  14.0
01FC:  GOTO   1FB
....................    output_high(RF_CS); 
01FD:  BCF    03.5
01FE:  BCF    36.1
01FF:  MOVF   36,W
0200:  BSF    03.5
0201:  MOVWF  07
0202:  BCF    03.5
0203:  BSF    07.1
....................  
....................    // EN_RXADDR 
....................    //Habilitar los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
0204:  BCF    36.1
0205:  MOVF   36,W
0206:  BSF    03.5
0207:  MOVWF  07
0208:  BCF    03.5
0209:  BCF    07.1
....................    spi_write(0x22); 
020A:  MOVF   13,W
020B:  MOVLW  22
020C:  MOVWF  13
020D:  BSF    03.5
020E:  BTFSS  14.0
020F:  GOTO   20E
....................    spi_write(0x07); 
0210:  BCF    03.5
0211:  MOVF   13,W
0212:  MOVLW  07
0213:  MOVWF  13
0214:  BSF    03.5
0215:  BTFSS  14.0
0216:  GOTO   215
....................    output_high(RF_CS); 
0217:  BCF    03.5
0218:  BCF    36.1
0219:  MOVF   36,W
021A:  BSF    03.5
021B:  MOVWF  07
021C:  BCF    03.5
021D:  BSF    07.1
....................  
....................    // SETUP_AW 
....................    //Configuración de la longitud de las direcciones. 
....................    //Direcciones de 5 bytes. 
....................    output_low(RF_CS); 
021E:  BCF    36.1
021F:  MOVF   36,W
0220:  BSF    03.5
0221:  MOVWF  07
0222:  BCF    03.5
0223:  BCF    07.1
....................    spi_write(0x23); 
0224:  MOVF   13,W
0225:  MOVLW  23
0226:  MOVWF  13
0227:  BSF    03.5
0228:  BTFSS  14.0
0229:  GOTO   228
....................    spi_write(0x03); 
022A:  BCF    03.5
022B:  MOVF   13,W
022C:  MOVLW  03
022D:  MOVWF  13
022E:  BSF    03.5
022F:  BTFSS  14.0
0230:  GOTO   22F
....................    output_high(RF_CS); 
0231:  BCF    03.5
0232:  BCF    36.1
0233:  MOVF   36,W
0234:  BSF    03.5
0235:  MOVWF  07
0236:  BCF    03.5
0237:  BSF    07.1
....................  
....................    //SETUP_RETR 
....................    //Configuración de las retrasmisiones en la transmisión. 
....................    //Diez retransmisiones cada 336us. 
....................    output_low(RF_CS); 
0238:  BCF    36.1
0239:  MOVF   36,W
023A:  BSF    03.5
023B:  MOVWF  07
023C:  BCF    03.5
023D:  BCF    07.1
....................    spi_write(0x24); 
023E:  MOVF   13,W
023F:  MOVLW  24
0240:  MOVWF  13
0241:  BSF    03.5
0242:  BTFSS  14.0
0243:  GOTO   242
....................    spi_write(0x0A); 
0244:  BCF    03.5
0245:  MOVF   13,W
0246:  MOVLW  0A
0247:  MOVWF  13
0248:  BSF    03.5
0249:  BTFSS  14.0
024A:  GOTO   249
....................    output_high(RF_CS); 
024B:  BCF    03.5
024C:  BCF    36.1
024D:  MOVF   36,W
024E:  BSF    03.5
024F:  MOVWF  07
0250:  BCF    03.5
0251:  BSF    07.1
....................  
....................    //RF_CH 
....................    //Configuración del canal. 
....................    //Canal elegido por el usuario (0x01 - 0x7F). 
....................    output_low(RF_CS); 
0252:  BCF    36.1
0253:  MOVF   36,W
0254:  BSF    03.5
0255:  MOVWF  07
0256:  BCF    03.5
0257:  BCF    07.1
....................    spi_write(0x25); 
0258:  MOVF   13,W
0259:  MOVLW  25
025A:  MOVWF  13
025B:  BSF    03.5
025C:  BTFSS  14.0
025D:  GOTO   25C
....................    spi_write(canal); 
025E:  BCF    03.5
025F:  MOVF   13,W
0260:  BSF    03.5
0261:  MOVF   41,W
0262:  BCF    03.5
0263:  MOVWF  13
0264:  BSF    03.5
0265:  BTFSS  14.0
0266:  GOTO   265
....................    output_high(RF_CS); 
0267:  BCF    03.5
0268:  BCF    36.1
0269:  MOVF   36,W
026A:  BSF    03.5
026B:  MOVWF  07
026C:  BCF    03.5
026D:  BSF    07.1
....................  
....................    //RF_SETUP 
....................    //Configuración aspectos RF. 
....................    //Ganancia máxima de LNA, 0dBm potencia de salida y 1Mbps de velocidad. 
....................    output_low(RF_CS); 
026E:  BCF    36.1
026F:  MOVF   36,W
0270:  BSF    03.5
0271:  MOVWF  07
0272:  BCF    03.5
0273:  BCF    07.1
....................    spi_write(0x26); 
0274:  MOVF   13,W
0275:  MOVLW  26
0276:  MOVWF  13
0277:  BSF    03.5
0278:  BTFSS  14.0
0279:  GOTO   278
....................    spi_write(0x07); 
027A:  BCF    03.5
027B:  MOVF   13,W
027C:  MOVLW  07
027D:  MOVWF  13
027E:  BSF    03.5
027F:  BTFSS  14.0
0280:  GOTO   27F
....................    output_high(RF_CS); 
0281:  BCF    03.5
0282:  BCF    36.1
0283:  MOVF   36,W
0284:  BSF    03.5
0285:  MOVWF  07
0286:  BCF    03.5
0287:  BSF    07.1
....................  
....................    //STATUS 
....................    //Reseteo del registro STATUS 
....................    output_low(RF_CS); 
0288:  BCF    36.1
0289:  MOVF   36,W
028A:  BSF    03.5
028B:  MOVWF  07
028C:  BCF    03.5
028D:  BCF    07.1
....................    spi_write(0x27); 
028E:  MOVF   13,W
028F:  MOVLW  27
0290:  MOVWF  13
0291:  BSF    03.5
0292:  BTFSS  14.0
0293:  GOTO   292
....................    spi_write(0x70); 
0294:  BCF    03.5
0295:  MOVF   13,W
0296:  MOVLW  70
0297:  MOVWF  13
0298:  BSF    03.5
0299:  BTFSS  14.0
029A:  GOTO   299
....................    output_high(RF_CS); 
029B:  BCF    03.5
029C:  BCF    36.1
029D:  MOVF   36,W
029E:  BSF    03.5
029F:  MOVWF  07
02A0:  BCF    03.5
02A1:  BSF    07.1
....................  
....................    //RX_PW_P0 
....................    //Nº de bytes en Pipe0. 
....................    //1 byte (ACK). 
....................    output_low(RF_CS); 
02A2:  BCF    36.1
02A3:  MOVF   36,W
02A4:  BSF    03.5
02A5:  MOVWF  07
02A6:  BCF    03.5
02A7:  BCF    07.1
....................    spi_write(0x31); 
02A8:  MOVF   13,W
02A9:  MOVLW  31
02AA:  MOVWF  13
02AB:  BSF    03.5
02AC:  BTFSS  14.0
02AD:  GOTO   2AC
....................    spi_write(0x01); 
02AE:  BCF    03.5
02AF:  MOVF   13,W
02B0:  MOVLW  01
02B1:  MOVWF  13
02B2:  BSF    03.5
02B3:  BTFSS  14.0
02B4:  GOTO   2B3
....................    output_high(RF_CS); 
02B5:  BCF    03.5
02B6:  BCF    36.1
02B7:  MOVF   36,W
02B8:  BSF    03.5
02B9:  MOVWF  07
02BA:  BCF    03.5
02BB:  BSF    07.1
....................  
....................    //RX_PW_P1 
....................    //Nº de bytes en Pipe1. 
....................    //10 byte (Direccion emisor y trama). 
....................    output_low(RF_CS); 
02BC:  BCF    36.1
02BD:  MOVF   36,W
02BE:  BSF    03.5
02BF:  MOVWF  07
02C0:  BCF    03.5
02C1:  BCF    07.1
....................    spi_write(0x32); 
02C2:  MOVF   13,W
02C3:  MOVLW  32
02C4:  MOVWF  13
02C5:  BSF    03.5
02C6:  BTFSS  14.0
02C7:  GOTO   2C6
....................    spi_write(0x0A); 
02C8:  BCF    03.5
02C9:  MOVF   13,W
02CA:  MOVLW  0A
02CB:  MOVWF  13
02CC:  BSF    03.5
02CD:  BTFSS  14.0
02CE:  GOTO   2CD
....................    output_high(RF_CS); 
02CF:  BCF    03.5
02D0:  BCF    36.1
02D1:  MOVF   36,W
02D2:  BSF    03.5
02D3:  MOVWF  07
02D4:  BCF    03.5
02D5:  BSF    07.1
....................  
....................    //RX_PW_P2 
....................    //Nº de bytes en Pipe2. 
....................    //10 byte (Direccion emisor y trama). 
....................    output_low(RF_CS); 
02D6:  BCF    36.1
02D7:  MOVF   36,W
02D8:  BSF    03.5
02D9:  MOVWF  07
02DA:  BCF    03.5
02DB:  BCF    07.1
....................    spi_write(0x33); 
02DC:  MOVF   13,W
02DD:  MOVLW  33
02DE:  MOVWF  13
02DF:  BSF    03.5
02E0:  BTFSS  14.0
02E1:  GOTO   2E0
....................    spi_write(0x0A); 
02E2:  BCF    03.5
02E3:  MOVF   13,W
02E4:  MOVLW  0A
02E5:  MOVWF  13
02E6:  BSF    03.5
02E7:  BTFSS  14.0
02E8:  GOTO   2E7
....................    output_high(RF_CS); 
02E9:  BCF    03.5
02EA:  BCF    36.1
02EB:  MOVF   36,W
02EC:  BSF    03.5
02ED:  MOVWF  07
02EE:  BCF    03.5
02EF:  BSF    07.1
.................... } 
02F0:  BSF    0A.3
02F1:  BCF    0A.4
02F2:  GOTO   28A (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                    RF_ON()                         * 
.................... //***************************************************** 
.................... //*Descripción:Esta rutina activa el módulo de        * 
.................... //*radiofrecuencia en modo escucha para poder recibir * 
.................... //*datos enviados a su dirección.                     * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_ON() 
.................... { 
....................  
....................    output_low(RF_CE); 
*
0308:  BCF    36.2
0309:  MOVF   36,W
030A:  BSF    03.5
030B:  MOVWF  07
030C:  BCF    03.5
030D:  BCF    07.2
....................  
....................    // CONFIG 
....................    //Se activa el modulo, se pone en recepción, 
....................    //se activa el CRC para que utilice 2 bytes. 
....................    output_low(RF_CS); 
030E:  BCF    36.1
030F:  MOVF   36,W
0310:  BSF    03.5
0311:  MOVWF  07
0312:  BCF    03.5
0313:  BCF    07.1
....................    spi_write(0x20); 
0314:  MOVF   13,W
0315:  MOVLW  20
0316:  MOVWF  13
0317:  BSF    03.5
0318:  BTFSS  14.0
0319:  GOTO   318
....................    spi_write(0x0F); 
031A:  BCF    03.5
031B:  MOVF   13,W
031C:  MOVLW  0F
031D:  MOVWF  13
031E:  BSF    03.5
031F:  BTFSS  14.0
0320:  GOTO   31F
....................    output_high(RF_CS); 
0321:  BCF    03.5
0322:  BCF    36.1
0323:  MOVF   36,W
0324:  BSF    03.5
0325:  MOVWF  07
0326:  BCF    03.5
0327:  BSF    07.1
....................  
....................    delay_ms(2); 
0328:  MOVLW  02
0329:  BSF    03.5
032A:  MOVWF  42
032B:  BCF    03.5
032C:  CALL   2F3
....................    output_high(RF_CE); 
032D:  BCF    36.2
032E:  MOVF   36,W
032F:  BSF    03.5
0330:  MOVWF  07
0331:  BCF    03.5
0332:  BSF    07.2
....................    delay_us(150); 
0333:  MOVLW  31
0334:  MOVWF  77
0335:  DECFSZ 77,F
0336:  GOTO   335
0337:  GOTO   338
.................... } 
0338:  BSF    0A.3
0339:  BCF    0A.4
033A:  GOTO   28D (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_OFF()                         * 
.................... //***************************************************** 
.................... //*Descripción:Este procedimiento desactiva el módulo * 
.................... //*de radiofrecuencia.                                * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_OFF() 
.................... { 
....................    output_low(RF_CE); 
....................  
....................    // CONFIG 
....................    //Se desactiva el modulo 
....................    output_low(RF_CS); 
....................    spi_write(0x20); 
....................    spi_write(0x0C); 
....................    output_high(RF_CS); 
.................... } 
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_SEND()                         * 
.................... //***************************************************** 
.................... //*Descripción:Esta función envía 8 Bytes de datos a  * 
.................... //*la dirección indicada informando de la correcta    * 
.................... //*recepción en el destinatario.                      * 
.................... //***************************************************** 
.................... //*Variables de entrada:- RF_DATA[]                   * 
.................... //*                     - RF_DIR 
.................... //*Variables de salida: -                             * 
.................... //*Salida:              - 0: Envío correcto (ACK OK)  * 
.................... //*                     - 1: No recepcibido (NO ACK)  * 
.................... //*                     - 2: No enviado               * 
.................... //***************************************************** 
.................... int RF_SEND() 
.................... { 
....................    int i; 
....................    int estado; 
....................  
....................  
....................    if(bit_test(INTCON,7)) 
*
0825:  BTFSS  0B.7
0826:  GOTO   029
....................       interRF=1; 
0827:  BSF    28.0
....................    else 
0828:  GOTO   02A
....................       interRF=0; 
0829:  BCF    28.0
....................  
....................    disable_interrupts(GLOBAL); 
082A:  BCF    0B.6
082B:  BCF    0B.7
082C:  BTFSC  0B.7
082D:  GOTO   02B
....................  
....................    // INICIO 
....................    output_low(RF_CE); 
082E:  BCF    36.2
082F:  MOVF   36,W
0830:  BSF    03.5
0831:  MOVWF  07
0832:  BCF    03.5
0833:  BCF    07.2
....................  
....................    //STATUS 
....................    //Reseteo del registro STATUS 
....................    output_low(RF_CS); 
0834:  BCF    36.1
0835:  MOVF   36,W
0836:  BSF    03.5
0837:  MOVWF  07
0838:  BCF    03.5
0839:  BCF    07.1
....................    spi_write(0x27); 
083A:  MOVF   13,W
083B:  MOVLW  27
083C:  MOVWF  13
083D:  BSF    03.5
083E:  BTFSS  14.0
083F:  GOTO   03E
....................    spi_write(0x70); 
0840:  BCF    03.5
0841:  MOVF   13,W
0842:  MOVLW  70
0843:  MOVWF  13
0844:  BSF    03.5
0845:  BTFSS  14.0
0846:  GOTO   045
....................    output_high(RF_CS); 
0847:  BCF    03.5
0848:  BCF    36.1
0849:  MOVF   36,W
084A:  BSF    03.5
084B:  MOVWF  07
084C:  BCF    03.5
084D:  BSF    07.1
....................  
....................    // EN_RXADDR 
....................    //Se habilita el Pipe0 para la recepción del ACK 
....................    output_low(RF_CS); 
084E:  BCF    36.1
084F:  MOVF   36,W
0850:  BSF    03.5
0851:  MOVWF  07
0852:  BCF    03.5
0853:  BCF    07.1
....................    spi_write(0x22); 
0854:  MOVF   13,W
0855:  MOVLW  22
0856:  MOVWF  13
0857:  BSF    03.5
0858:  BTFSS  14.0
0859:  GOTO   058
....................    spi_write(0x01); 
085A:  BCF    03.5
085B:  MOVF   13,W
085C:  MOVLW  01
085D:  MOVWF  13
085E:  BSF    03.5
085F:  BTFSS  14.0
0860:  GOTO   05F
....................    output_high(RF_CS); 
0861:  BCF    03.5
0862:  BCF    36.1
0863:  MOVF   36,W
0864:  BSF    03.5
0865:  MOVWF  07
0866:  BCF    03.5
0867:  BSF    07.1
....................  
....................    // TX_ADDR 
....................    //Se configura la dirección de transmisión=RF_DIR 
....................    output_low(RF_CS); 
0868:  BCF    36.1
0869:  MOVF   36,W
086A:  BSF    03.5
086B:  MOVWF  07
086C:  BCF    03.5
086D:  BCF    07.1
....................    spi_write(0x30); 
086E:  MOVF   13,W
086F:  MOVLW  30
0870:  MOVWF  13
0871:  BSF    03.5
0872:  BTFSS  14.0
0873:  GOTO   072
....................    spi_write(RF_DIR); 
0874:  BCF    03.5
0875:  MOVF   35,W
0876:  MOVWF  13
0877:  BSF    03.5
0878:  BTFSS  14.0
0879:  GOTO   078
....................    spi_write(0xC2); 
087A:  BCF    03.5
087B:  MOVF   13,W
087C:  MOVLW  C2
087D:  MOVWF  13
087E:  BSF    03.5
087F:  BTFSS  14.0
0880:  GOTO   07F
....................    spi_write(0xC2); 
0881:  BCF    03.5
0882:  MOVF   13,W
0883:  MOVLW  C2
0884:  MOVWF  13
0885:  BSF    03.5
0886:  BTFSS  14.0
0887:  GOTO   086
....................    spi_write(0xC2); 
0888:  BCF    03.5
0889:  MOVF   13,W
088A:  MOVLW  C2
088B:  MOVWF  13
088C:  BSF    03.5
088D:  BTFSS  14.0
088E:  GOTO   08D
....................    spi_write(0xC2); 
088F:  BCF    03.5
0890:  MOVF   13,W
0891:  MOVLW  C2
0892:  MOVWF  13
0893:  BSF    03.5
0894:  BTFSS  14.0
0895:  GOTO   094
....................    output_high(RF_CS); 
0896:  BCF    03.5
0897:  BCF    36.1
0898:  MOVF   36,W
0899:  BSF    03.5
089A:  MOVWF  07
089B:  BCF    03.5
089C:  BSF    07.1
....................  
....................    // RX_ADDR_P0 
....................    //Para la recepción del ACK se debe configurar el Pipe0 con 
....................    //la misma dirección a trasmitir. 
....................    output_low(RF_CS); 
089D:  BCF    36.1
089E:  MOVF   36,W
089F:  BSF    03.5
08A0:  MOVWF  07
08A1:  BCF    03.5
08A2:  BCF    07.1
....................    spi_write(0x2A); 
08A3:  MOVF   13,W
08A4:  MOVLW  2A
08A5:  MOVWF  13
08A6:  BSF    03.5
08A7:  BTFSS  14.0
08A8:  GOTO   0A7
....................    spi_write(RF_DIR); 
08A9:  BCF    03.5
08AA:  MOVF   35,W
08AB:  MOVWF  13
08AC:  BSF    03.5
08AD:  BTFSS  14.0
08AE:  GOTO   0AD
....................    spi_write(0xC2); 
08AF:  BCF    03.5
08B0:  MOVF   13,W
08B1:  MOVLW  C2
08B2:  MOVWF  13
08B3:  BSF    03.5
08B4:  BTFSS  14.0
08B5:  GOTO   0B4
....................    spi_write(0xC2); 
08B6:  BCF    03.5
08B7:  MOVF   13,W
08B8:  MOVLW  C2
08B9:  MOVWF  13
08BA:  BSF    03.5
08BB:  BTFSS  14.0
08BC:  GOTO   0BB
....................    spi_write(0xC2); 
08BD:  BCF    03.5
08BE:  MOVF   13,W
08BF:  MOVLW  C2
08C0:  MOVWF  13
08C1:  BSF    03.5
08C2:  BTFSS  14.0
08C3:  GOTO   0C2
....................    spi_write(0xC2); 
08C4:  BCF    03.5
08C5:  MOVF   13,W
08C6:  MOVLW  C2
08C7:  MOVWF  13
08C8:  BSF    03.5
08C9:  BTFSS  14.0
08CA:  GOTO   0C9
....................    output_high(RF_CS); 
08CB:  BCF    03.5
08CC:  BCF    36.1
08CD:  MOVF   36,W
08CE:  BSF    03.5
08CF:  MOVWF  07
08D0:  BCF    03.5
08D1:  BSF    07.1
....................  
....................    // RX_ADDR_P1 
....................    //Se mete en RF_DIR la direccion propia. 
....................    //De esta manera el receptor sabe la dirección 
....................    //del transmisor. 
....................    output_low(RF_CS); 
08D2:  BCF    36.1
08D3:  MOVF   36,W
08D4:  BSF    03.5
08D5:  MOVWF  07
08D6:  BCF    03.5
08D7:  BCF    07.1
....................    spi_write(0x0B); 
08D8:  MOVF   13,W
08D9:  MOVLW  0B
08DA:  MOVWF  13
08DB:  BSF    03.5
08DC:  BTFSS  14.0
08DD:  GOTO   0DC
....................    RF_DIR=spi_read(0); 
08DE:  BCF    03.5
08DF:  MOVF   13,W
08E0:  CLRF   13
08E1:  BSF    03.5
08E2:  BTFSS  14.0
08E3:  GOTO   0E2
08E4:  BCF    03.5
08E5:  MOVF   13,W
08E6:  MOVWF  35
....................    spi_read(0); 
08E7:  MOVF   13,W
08E8:  CLRF   13
08E9:  BSF    03.5
08EA:  BTFSS  14.0
08EB:  GOTO   0EA
....................    spi_read(0); 
08EC:  BCF    03.5
08ED:  MOVF   13,W
08EE:  CLRF   13
08EF:  BSF    03.5
08F0:  BTFSS  14.0
08F1:  GOTO   0F0
....................    spi_read(0); 
08F2:  BCF    03.5
08F3:  MOVF   13,W
08F4:  CLRF   13
08F5:  BSF    03.5
08F6:  BTFSS  14.0
08F7:  GOTO   0F6
....................    spi_read(0); 
08F8:  BCF    03.5
08F9:  MOVF   13,W
08FA:  CLRF   13
08FB:  BSF    03.5
08FC:  BTFSS  14.0
08FD:  GOTO   0FC
....................    output_high(RF_CS); 
08FE:  BCF    03.5
08FF:  BCF    36.1
0900:  MOVF   36,W
0901:  BSF    03.5
0902:  MOVWF  07
0903:  BCF    03.5
0904:  BSF    07.1
....................  
....................    // W_TX_PAYLOAD 
....................    //Se manda los datos al transductor 
....................    output_low(RF_CS); 
0905:  BCF    36.1
0906:  MOVF   36,W
0907:  BSF    03.5
0908:  MOVWF  07
0909:  BCF    03.5
090A:  BCF    07.1
....................    spi_write(0xA0); 
090B:  MOVF   13,W
090C:  MOVLW  A0
090D:  MOVWF  13
090E:  BSF    03.5
090F:  BTFSS  14.0
0910:  GOTO   10F
....................  
....................    DATA_N_SND++; 
0911:  BCF    03.5
0912:  INCF   2B,F
....................    spi_write(DATA_N_SND); 
0913:  MOVF   2B,W
0914:  MOVWF  13
0915:  BSF    03.5
0916:  BTFSS  14.0
0917:  GOTO   116
....................    spi_write(RF_DIR); 
0918:  BCF    03.5
0919:  MOVF   35,W
091A:  MOVWF  13
091B:  BSF    03.5
091C:  BTFSS  14.0
091D:  GOTO   11C
....................    for (i=0;i<8;i++) 
091E:  CLRF   43
091F:  MOVF   43,W
0920:  SUBLW  07
0921:  BTFSS  03.0
0922:  GOTO   134
....................       spi_write(RF_DATA[i]); 
0923:  MOVLW  2D
0924:  ADDWF  43,W
0925:  MOVWF  04
0926:  BCF    03.7
0927:  MOVF   00,W
0928:  MOVWF  45
0929:  BCF    03.5
092A:  MOVF   13,W
092B:  BSF    03.5
092C:  MOVF   45,W
092D:  BCF    03.5
092E:  MOVWF  13
092F:  BSF    03.5
0930:  BTFSS  14.0
0931:  GOTO   130
0932:  INCF   43,F
0933:  GOTO   11F
....................  
....................    output_high(RF_CS); 
0934:  BCF    03.5
0935:  BCF    36.1
0936:  MOVF   36,W
0937:  BSF    03.5
0938:  MOVWF  07
0939:  BCF    03.5
093A:  BSF    07.1
....................  
....................    // CONFIG 
....................    //Se pasa a modo transmisión. 
....................    output_low(RF_CS); 
093B:  BCF    36.1
093C:  MOVF   36,W
093D:  BSF    03.5
093E:  MOVWF  07
093F:  BCF    03.5
0940:  BCF    07.1
....................    spi_write(0x20); 
0941:  MOVF   13,W
0942:  MOVLW  20
0943:  MOVWF  13
0944:  BSF    03.5
0945:  BTFSS  14.0
0946:  GOTO   145
....................    spi_write(0x0E); 
0947:  BCF    03.5
0948:  MOVF   13,W
0949:  MOVLW  0E
094A:  MOVWF  13
094B:  BSF    03.5
094C:  BTFSS  14.0
094D:  GOTO   14C
....................    output_high(RF_CS); 
094E:  BCF    03.5
094F:  BCF    36.1
0950:  MOVF   36,W
0951:  BSF    03.5
0952:  MOVWF  07
0953:  BCF    03.5
0954:  BSF    07.1
....................  
....................    // Pulso de comienzo de envío 
....................    output_high(RF_CE); 
0955:  BCF    36.2
0956:  MOVF   36,W
0957:  BSF    03.5
0958:  MOVWF  07
0959:  BCF    03.5
095A:  BSF    07.2
....................    delay_us(15); 
095B:  MOVLW  04
095C:  MOVWF  77
095D:  DECFSZ 77,F
095E:  GOTO   15D
095F:  GOTO   160
....................    output_low(RF_CE); 
0960:  BCF    36.2
0961:  MOVF   36,W
0962:  BSF    03.5
0963:  MOVWF  07
0964:  BCF    03.5
0965:  BCF    07.2
....................  
....................    noRF=0; 
0966:  CLRF   2A
0967:  CLRF   29
....................  
....................    while (input(RF_IRQ)==1) { 
0968:  BSF    03.5
0969:  BSF    06.0
096A:  BCF    03.5
096B:  BTFSS  06.0
096C:  GOTO   178
....................       noRF++; 
096D:  INCF   29,F
096E:  BTFSC  03.2
096F:  INCF   2A,F
....................       //Si no da respuesta en 7ms, no se ha enviado. 
....................       if(noRF==500){ 
0970:  MOVF   29,W
0971:  SUBLW  F4
0972:  BTFSS  03.2
0973:  GOTO   177
0974:  DECFSZ 2A,W
0975:  GOTO   177
....................       break; 
0976:  GOTO   178
....................          } 
....................    } 
0977:  GOTO   168
....................  
....................  
....................    // STATUS 
....................    //Lectura del estado en el registro estatus. 
....................    output_low(RF_CS); 
0978:  BCF    36.1
0979:  MOVF   36,W
097A:  BSF    03.5
097B:  MOVWF  07
097C:  BCF    03.5
097D:  BCF    07.1
....................    estado=spi_read(0x27); 
097E:  MOVF   13,W
097F:  MOVLW  27
0980:  MOVWF  13
0981:  BSF    03.5
0982:  BTFSS  14.0
0983:  GOTO   182
0984:  BCF    03.5
0985:  MOVF   13,W
0986:  BSF    03.5
0987:  MOVWF  44
....................    spi_write(0x70); 
0988:  BCF    03.5
0989:  MOVF   13,W
098A:  MOVLW  70
098B:  MOVWF  13
098C:  BSF    03.5
098D:  BTFSS  14.0
098E:  GOTO   18D
....................    output_high(RF_CS); 
098F:  BCF    03.5
0990:  BCF    36.1
0991:  MOVF   36,W
0992:  BSF    03.5
0993:  MOVWF  07
0994:  BCF    03.5
0995:  BSF    07.1
....................  
....................  
....................    // EN_RXADDR 
....................    //Habilitar los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
0996:  BCF    36.1
0997:  MOVF   36,W
0998:  BSF    03.5
0999:  MOVWF  07
099A:  BCF    03.5
099B:  BCF    07.1
....................    spi_write(0x22); 
099C:  MOVF   13,W
099D:  MOVLW  22
099E:  MOVWF  13
099F:  BSF    03.5
09A0:  BTFSS  14.0
09A1:  GOTO   1A0
....................    spi_write(0x07); 
09A2:  BCF    03.5
09A3:  MOVF   13,W
09A4:  MOVLW  07
09A5:  MOVWF  13
09A6:  BSF    03.5
09A7:  BTFSS  14.0
09A8:  GOTO   1A7
....................    output_high(RF_CS); 
09A9:  BCF    03.5
09AA:  BCF    36.1
09AB:  MOVF   36,W
09AC:  BSF    03.5
09AD:  MOVWF  07
09AE:  BCF    03.5
09AF:  BSF    07.1
....................  
....................       // TX_FLUSH 
....................    //Limpieza de la FIFO de salida 
....................    output_low(RF_CS); 
09B0:  BCF    36.1
09B1:  MOVF   36,W
09B2:  BSF    03.5
09B3:  MOVWF  07
09B4:  BCF    03.5
09B5:  BCF    07.1
....................    spi_write(0xE1); 
09B6:  MOVF   13,W
09B7:  MOVLW  E1
09B8:  MOVWF  13
09B9:  BSF    03.5
09BA:  BTFSS  14.0
09BB:  GOTO   1BA
....................    output_high(RF_CS); 
09BC:  BCF    03.5
09BD:  BCF    36.1
09BE:  MOVF   36,W
09BF:  BSF    03.5
09C0:  MOVWF  07
09C1:  BCF    03.5
09C2:  BSF    07.1
....................  
....................    // CONFIG 
....................    //Paso a modo recepción 
....................    output_low(RF_CS); 
09C3:  BCF    36.1
09C4:  MOVF   36,W
09C5:  BSF    03.5
09C6:  MOVWF  07
09C7:  BCF    03.5
09C8:  BCF    07.1
....................    spi_write(0x20); 
09C9:  MOVF   13,W
09CA:  MOVLW  20
09CB:  MOVWF  13
09CC:  BSF    03.5
09CD:  BTFSS  14.0
09CE:  GOTO   1CD
....................    spi_write(0x0F); 
09CF:  BCF    03.5
09D0:  MOVF   13,W
09D1:  MOVLW  0F
09D2:  MOVWF  13
09D3:  BSF    03.5
09D4:  BTFSS  14.0
09D5:  GOTO   1D4
....................    output_high(RF_CS); 
09D6:  BCF    03.5
09D7:  BCF    36.1
09D8:  MOVF   36,W
09D9:  BSF    03.5
09DA:  MOVWF  07
09DB:  BCF    03.5
09DC:  BSF    07.1
....................  
....................    // FIN 
....................    output_high(RF_CE); 
09DD:  BCF    36.2
09DE:  MOVF   36,W
09DF:  BSF    03.5
09E0:  MOVWF  07
09E1:  BCF    03.5
09E2:  BSF    07.2
....................  
....................    delay_us(150); 
09E3:  MOVLW  31
09E4:  MOVWF  77
09E5:  DECFSZ 77,F
09E6:  GOTO   1E5
09E7:  GOTO   1E8
....................  
....................    //Si no da respuesta en 7ms, no se ha enviado. 
....................    if(noRF==500){ 
09E8:  MOVF   29,W
09E9:  SUBLW  F4
09EA:  BTFSS  03.2
09EB:  GOTO   1F6
09EC:  DECFSZ 2A,W
09ED:  GOTO   1F6
....................         if(interRF==1) 
09EE:  BTFSS  28.0
09EF:  GOTO   1F2
....................         enable_interrupts(GLOBAL); 
09F0:  MOVLW  C0
09F1:  IORWF  0B,F
....................         clear_interrupt(int_ext); 
09F2:  BCF    0B.1
....................         return(2); 
09F3:  MOVLW  02
09F4:  MOVWF  78
09F5:  GOTO   20F
....................    } 
....................  
....................    //estado 
....................    //Chequeo de los bit del registro STATUS que indican si se ha recibido 
....................    //ACK y si se ha terminado las retrasmisiones sin ningun ACK. 
....................    if ((bit_test(estado,4)==0) && (bit_test(estado,5)==1)){ 
09F6:  BSF    03.5
09F7:  BTFSC  44.4
09F8:  GOTO   206
09F9:  BTFSS  44.5
09FA:  GOTO   206
....................       if(interRF==1) 
09FB:  BCF    03.5
09FC:  BTFSS  28.0
09FD:  GOTO   200
....................       enable_interrupts(GLOBAL); 
09FE:  MOVLW  C0
09FF:  IORWF  0B,F
....................       clear_interrupt(int_ext); 
0A00:  BCF    0B.1
....................       return(0); 
0A01:  MOVLW  00
0A02:  MOVWF  78
0A03:  GOTO   20F
....................       } 
....................    else{ 
0A04:  GOTO   20F
0A05:  BSF    03.5
....................       if(interRF==1) 
0A06:  BCF    03.5
0A07:  BTFSS  28.0
0A08:  GOTO   20B
....................       enable_interrupts(GLOBAL); 
0A09:  MOVLW  C0
0A0A:  IORWF  0B,F
....................       clear_interrupt(int_ext); 
0A0B:  BCF    0B.1
....................       return(1); 
0A0C:  MOVLW  01
0A0D:  MOVWF  78
0A0E:  GOTO   20F
....................       } 
.................... } 
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_RECEIVE()                      * 
.................... //***************************************************** 
.................... //*Descripción: Esta rutina se encarga de comprobar si* 
.................... //*se ha producido una recepción y de ser así,        * 
.................... //*devuelve la trama recibida.                        * 
.................... //***************************************************** 
.................... //*Variables de entrada:-                             * 
.................... //*Variables de salida: - RF_DATA[]                   * 
.................... //*                     - RF_DIR                      * 
.................... //*Salida:         - 0: Recepción correcta y única    * 
.................... //*                - 1: Recepción correcta y múltiple * 
.................... //*                - 2: No se ha producido recepción  * 
.................... //*                - 3: No se ha producido recepción  * 
.................... //***************************************************** 
.................... int RF_RECEIVE() 
.................... { 
....................  
....................    int i; 
....................    int mas; 
....................    int estado; 
....................  
....................    if (input(RF_IRQ)==1 && RCVNW==0){ 
*
0033:  BSF    03.5
0034:  BSF    06.0
0035:  BCF    03.5
0036:  BTFSS  06.0
0037:  GOTO   03D
0038:  BTFSC  28.1
0039:  GOTO   03D
....................       return (2); 
003A:  MOVLW  02
003B:  MOVWF  78
003C:  GOTO   0CC
....................       } 
....................  
....................    //STATUS 
....................    //Lectura y reseteo del registro STATUS 
....................    output_low(RF_CS); 
003D:  BCF    36.1
003E:  MOVF   36,W
003F:  BSF    03.5
0040:  MOVWF  07
0041:  BCF    03.5
0042:  BCF    07.1
....................    estado=spi_read(0x27); 
0043:  MOVF   13,W
0044:  MOVLW  27
0045:  MOVWF  13
0046:  BSF    03.5
0047:  BTFSS  14.0
0048:  GOTO   047
0049:  BCF    03.5
004A:  MOVF   13,W
004B:  BSF    03.5
004C:  MOVWF  5E
....................    spi_write(0x70); 
004D:  BCF    03.5
004E:  MOVF   13,W
004F:  MOVLW  70
0050:  MOVWF  13
0051:  BSF    03.5
0052:  BTFSS  14.0
0053:  GOTO   052
....................    output_high(RF_CS); 
0054:  BCF    03.5
0055:  BCF    36.1
0056:  MOVF   36,W
0057:  BSF    03.5
0058:  MOVWF  07
0059:  BCF    03.5
005A:  BSF    07.1
....................  
....................    //estado 
....................    //Chequeo de la interrupción de recepción. 
....................    if (bit_test(estado,6)==0 && RCVNW==0){ 
005B:  BSF    03.5
005C:  BTFSC  5E.6
005D:  GOTO   067
005E:  BCF    03.5
005F:  BTFSS  28.1
0060:  GOTO   063
0061:  BSF    03.5
0062:  GOTO   067
....................       return(3); 
0063:  MOVLW  03
0064:  MOVWF  78
0065:  GOTO   0CC
0066:  BSF    03.5
....................       } 
....................  
....................    //R_RX_PAYLOAD 
....................    //Lectura de los datos recibidos. 
....................    output_low(RF_CS); 
0067:  BCF    03.5
0068:  BCF    36.1
0069:  MOVF   36,W
006A:  BSF    03.5
006B:  MOVWF  07
006C:  BCF    03.5
006D:  BCF    07.1
....................    spi_write(0x61); 
006E:  MOVF   13,W
006F:  MOVLW  61
0070:  MOVWF  13
0071:  BSF    03.5
0072:  BTFSS  14.0
0073:  GOTO   072
....................    DATA_N_RCV=spi_read(0); 
0074:  BCF    03.5
0075:  MOVF   13,W
0076:  CLRF   13
0077:  BSF    03.5
0078:  BTFSS  14.0
0079:  GOTO   078
007A:  BCF    03.5
007B:  MOVF   13,W
007C:  MOVWF  2C
....................    RF_DIR=spi_read(0); 
007D:  MOVF   13,W
007E:  CLRF   13
007F:  BSF    03.5
0080:  BTFSS  14.0
0081:  GOTO   080
0082:  BCF    03.5
0083:  MOVF   13,W
0084:  MOVWF  35
....................    for (i=0;i<8;i++) 
0085:  BSF    03.5
0086:  CLRF   5C
0087:  MOVF   5C,W
0088:  SUBLW  07
0089:  BTFSS  03.0
008A:  GOTO   09B
....................    { 
....................       RF_DATA[i]=spi_read(0); 
008B:  MOVLW  2D
008C:  ADDWF  5C,W
008D:  MOVWF  04
008E:  BCF    03.7
008F:  BCF    03.5
0090:  MOVF   13,W
0091:  CLRF   13
0092:  BSF    03.5
0093:  BTFSS  14.0
0094:  GOTO   093
0095:  BCF    03.5
0096:  MOVF   13,W
0097:  MOVWF  00
....................    } 
0098:  BSF    03.5
0099:  INCF   5C,F
009A:  GOTO   087
....................    output_high(RF_CS); 
009B:  BCF    03.5
009C:  BCF    36.1
009D:  MOVF   36,W
009E:  BSF    03.5
009F:  MOVWF  07
00A0:  BCF    03.5
00A1:  BSF    07.1
....................  
....................    //FIFO_STATUS 
....................    //Comprobación del estado de la FIFO de 
....................    //recepción para comprobar si hay más datos 
....................    output_low(RF_CS); 
00A2:  BCF    36.1
00A3:  MOVF   36,W
00A4:  BSF    03.5
00A5:  MOVWF  07
00A6:  BCF    03.5
00A7:  BCF    07.1
....................    spi_write(0x17); 
00A8:  MOVF   13,W
00A9:  MOVLW  17
00AA:  MOVWF  13
00AB:  BSF    03.5
00AC:  BTFSS  14.0
00AD:  GOTO   0AC
....................    mas=spi_read(0); 
00AE:  BCF    03.5
00AF:  MOVF   13,W
00B0:  CLRF   13
00B1:  BSF    03.5
00B2:  BTFSS  14.0
00B3:  GOTO   0B2
00B4:  BCF    03.5
00B5:  MOVF   13,W
00B6:  BSF    03.5
00B7:  MOVWF  5D
....................    output_high(RF_CS); 
00B8:  BCF    03.5
00B9:  BCF    36.1
00BA:  MOVF   36,W
00BB:  BSF    03.5
00BC:  MOVWF  07
00BD:  BCF    03.5
00BE:  BSF    07.1
....................  
....................    if (bit_test(mas,0)==0){ 
00BF:  BSF    03.5
00C0:  BTFSC  5D.0
00C1:  GOTO   0C8
....................       RCVNW=1; 
00C2:  BCF    03.5
00C3:  BSF    28.1
....................       return(1); 
00C4:  MOVLW  01
00C5:  MOVWF  78
00C6:  GOTO   0CC
00C7:  BSF    03.5
....................    } 
....................       RCVNW=0; 
00C8:  BCF    03.5
00C9:  BCF    28.1
....................       return(0); 
00CA:  MOVLW  00
00CB:  MOVWF  78
.................... } 
00CC:  RETLW  00
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0A35:  CLRF   37
0A36:  CLRF   38
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #byte porta=0x05 
.................... #byte portb=0x06 
....................  
.................... int8 buffer[8];  // Buffer de 8 bytes. 
.................... char buff[32];   //Buffer para el frame. 
.................... int8 ret2; 
....................  
.................... float temperatura = 0.0; 
0A37:  CLRF   62
0A38:  CLRF   63
0A39:  CLRF   64
0A3A:  CLRF   65
....................  
.................... //----------------------------------------------------- 
.................... // Identificador (Nombre del dispositivo). 
.................... // Nota: Vector de 8 bytes. 7 para caracteres, 1 para vector NULL. 
.................... char* ident[8] = "Mote_01";  
0A3B:  MOVLW  4D
0A3C:  BSF    03.5
0A3D:  MOVWF  20
0A3E:  MOVLW  6F
0A3F:  MOVWF  21
0A40:  MOVLW  74
0A41:  MOVWF  22
0A42:  MOVLW  65
0A43:  MOVWF  23
0A44:  MOVLW  5F
0A45:  MOVWF  24
0A46:  MOVLW  30
0A47:  MOVWF  25
0A48:  MOVLW  31
0A49:  MOVWF  26
0A4A:  CLRF   27
0A4B:  BCF    03.5
0A4C:  CLRF   67
0A4D:  MOVLW  A0
0A4E:  MOVWF  66
0A4F:  CLRF   68
0A50:  CLRF   69
0A51:  CLRF   6A
0A52:  CLRF   6B
0A53:  CLRF   6C
0A54:  CLRF   6D
0A55:  CLRF   6E
0A56:  CLRF   6F
0A57:  CLRF   70
0A58:  CLRF   71
0A59:  CLRF   72
0A5A:  CLRF   73
0A5B:  CLRF   74
0A5C:  CLRF   75
.................... //----------------------------------------------------- 
....................  
....................  
.................... // Funcion envio del frame en 4 bloques de 8 bits. 
.................... void Send_frame(){ 
....................    int i; 
....................    int fc; 
....................    for (fc=0;fc<32;fc++){ 
*
0800:  BSF    03.5
0801:  CLRF   42
0802:  MOVF   42,W
0803:  SUBLW  1F
0804:  BTFSS  03.0
0805:  GOTO   214
....................        for (i=0;i<8;i++){ 
0806:  CLRF   41
0807:  MOVF   41,W
0808:  SUBLW  07
0809:  BTFSS  03.0
080A:  GOTO   021
....................           RF_DATA[i] = Buff[fc]; 
080B:  MOVLW  2D
080C:  ADDWF  41,W
080D:  MOVWF  43
080E:  CLRF   44
080F:  BTFSC  03.0
0810:  INCF   44,F
0811:  MOVLW  41
0812:  ADDWF  42,W
0813:  MOVWF  04
0814:  BCF    03.7
0815:  MOVF   00,W
0816:  MOVWF  45
0817:  MOVF   43,W
0818:  MOVWF  04
0819:  BCF    03.7
081A:  BTFSC  44.0
081B:  BSF    03.7
081C:  MOVF   45,W
081D:  MOVWF  00
....................           fc++;          
081E:  INCF   42,F
....................        } 
081F:  INCF   41,F
0820:  GOTO   007
....................        fc--; //Restamos 1 para no saltarnos un byte en el siguiente bucle, pues 
0821:  DECF   42,F
....................              //se lo suma antes de ejecutar las instrucciones. 
....................        RF_DIR=0x08;           // Dirección del receptor. 
0822:  MOVLW  08
0823:  BCF    03.5
0824:  MOVWF  35
....................        ret2=RF_SEND();        // Enviar datos. 
*
0A0F:  MOVF   78,W
0A10:  MOVWF  61
....................         
....................    } 
0A11:  BSF    03.5
0A12:  INCF   42,F
0A13:  GOTO   002
.................... } 
0A14:  BCF    03.5
0A15:  BSF    0A.3
0A16:  BCF    0A.4
0A17:  GOTO   4A9 (RETURN)
....................  
.................... // Interrupcion. Lee el paquete recibido. 
.................... #int_ext 
.................... void int_RB0() 
.................... { 
....................    int8 ret1; 
....................     
....................    ret1 = RF_RECEIVE(); 
*
00CD:  CALL   033
00CE:  MOVF   78,W
00CF:  BSF    03.5
00D0:  MOVWF  5B
....................    if ( (ret1 == 0) || (ret1 == 1) ) 
00D1:  MOVF   5B,F
00D2:  BTFSC  03.2
00D3:  GOTO   0D6
00D4:  DECFSZ 5B,W
00D5:  GOTO   0F1
....................    { 
....................       do 
....................       {  
....................         //Asigno los 8 bytes de entrada a un buffer secundario. 
....................         buffer[0] = RF_DATA[0]; 
00D6:  BCF    03.5
00D7:  MOVF   2D,W
00D8:  MOVWF  39
....................         buffer[1] = RF_DATA[1]; 
00D9:  MOVF   2E,W
00DA:  MOVWF  3A
....................         buffer[2] = RF_DATA[2]; 
00DB:  MOVF   2F,W
00DC:  MOVWF  3B
....................         buffer[3] = RF_DATA[3]; 
00DD:  MOVF   30,W
00DE:  MOVWF  3C
....................         buffer[4] = RF_DATA[4];  
00DF:  MOVF   31,W
00E0:  MOVWF  3D
....................         buffer[5] = RF_DATA[5];  
00E1:  MOVF   32,W
00E2:  MOVWF  3E
....................         buffer[6] = RF_DATA[6];  
00E3:  MOVF   33,W
00E4:  MOVWF  3F
....................         buffer[7] = RF_DATA[7];  
00E5:  MOVF   34,W
00E6:  MOVWF  40
....................         ret1 = RF_RECEIVE();  
00E7:  CALL   033
00E8:  MOVF   78,W
00E9:  BSF    03.5
00EA:  MOVWF  5B
....................          
....................       }  while ( (ret1 == 0) || (ret1 == 1) ); 
00EB:  MOVF   5B,F
00EC:  BTFSC  03.2
00ED:  GOTO   0D6
00EE:  DECFSZ 5B,W
00EF:  GOTO   0F1
00F0:  GOTO   0D6
....................    }   
.................... } 
....................  
00F1:  BCF    03.5
00F2:  BCF    0B.1
00F3:  BCF    0A.3
00F4:  BCF    0A.4
00F5:  GOTO   01D
.................... void main() 
.................... {   
*
0A18:  CLRF   04
0A19:  BCF    03.7
0A1A:  MOVLW  1F
0A1B:  ANDWF  03,F
0A1C:  BSF    03.5
0A1D:  BSF    1F.0
0A1E:  BSF    1F.1
0A1F:  BSF    1F.2
0A20:  BCF    1F.3
0A21:  MOVLW  07
0A22:  MOVWF  1C
....................     
....................    char s[7];  //Variable string para el dato de la temperatura. 
....................    char frase[14] = "Temperatura: "; 
*
0A5F:  MOVLW  54
0A60:  BSF    03.5
0A61:  MOVWF  2F
0A62:  MOVLW  65
0A63:  MOVWF  30
0A64:  MOVLW  6D
0A65:  MOVWF  31
0A66:  MOVLW  70
0A67:  MOVWF  32
0A68:  MOVLW  65
0A69:  MOVWF  33
0A6A:  MOVLW  72
0A6B:  MOVWF  34
0A6C:  MOVLW  61
0A6D:  MOVWF  35
0A6E:  MOVLW  74
0A6F:  MOVWF  36
0A70:  MOVLW  75
0A71:  MOVWF  37
0A72:  MOVLW  72
0A73:  MOVWF  38
0A74:  MOVLW  61
0A75:  MOVWF  39
0A76:  MOVLW  3A
0A77:  MOVWF  3A
0A78:  MOVLW  20
0A79:  MOVWF  3B
0A7A:  CLRF   3C
....................    //Variables para el frame de pruebas. 
....................    int g; 
....................    int gg; 
....................    
....................    RF_INT_EN();              // Habilitar interrupción RB0/INT. 
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  GOTO   0F6
0A7E:  BSF    0A.3
....................    RF_CONFIG_SPI();          // Configurar módulo SPI del PIC. 
0A7F:  BCF    0A.3
0A80:  GOTO   104
0A81:  BSF    0A.3
....................    RF_CONFIG(0x40,0x01);     // Configurar módulo RF canal y dirección. 
0A82:  MOVLW  40
0A83:  BSF    03.5
0A84:  MOVWF  41
0A85:  MOVLW  01
0A86:  MOVWF  42
0A87:  BCF    0A.3
0A88:  BCF    03.5
0A89:  GOTO   122
0A8A:  BSF    0A.3
....................    RF_ON();                  // Activar el módulo RF. 
0A8B:  BCF    0A.3
0A8C:  GOTO   308
0A8D:  BSF    0A.3
....................     
....................    delay_ms(5); 
0A8E:  MOVLW  05
0A8F:  BSF    03.5
0A90:  MOVWF  42
0A91:  BCF    0A.3
0A92:  BCF    03.5
0A93:  CALL   2F3
0A94:  BSF    0A.3
....................     
....................    set_tris_a(0b111111);     // Todo el puerto A como entradas. 
0A95:  MOVLW  3F
0A96:  BSF    03.5
0A97:  MOVWF  05
....................     
....................    output_low(PIN_C0);       //Led de estado apagado. 
0A98:  BCF    03.5
0A99:  BCF    36.0
0A9A:  MOVF   36,W
0A9B:  BSF    03.5
0A9C:  MOVWF  07
0A9D:  BCF    03.5
0A9E:  BCF    07.0
....................     
....................    // Configurar ADC. 
....................    setup_adc_ports(all_analog);//Definimos las entradas analógicas. 
0A9F:  BSF    03.5
0AA0:  BCF    1F.0
0AA1:  BCF    1F.1
0AA2:  BCF    1F.2
0AA3:  BCF    1F.3
....................    delay_us (20); 
0AA4:  MOVLW  06
0AA5:  MOVWF  77
0AA6:  DECFSZ 77,F
0AA7:  GOTO   2A6
0AA8:  NOP
....................    setup_adc (ADC_CLOCK_INTERNAL);//Configuramos el modo del convertidor. 
0AA9:  BCF    1F.6
0AAA:  BCF    03.5
0AAB:  BSF    1F.6
0AAC:  BSF    1F.7
0AAD:  BSF    03.5
0AAE:  BSF    1F.7
0AAF:  BCF    03.5
0AB0:  BSF    1F.0
....................    delay_ms (20); 
0AB1:  MOVLW  14
0AB2:  BSF    03.5
0AB3:  MOVWF  42
0AB4:  BCF    0A.3
0AB5:  BCF    03.5
0AB6:  CALL   2F3
0AB7:  BSF    0A.3
....................     
....................    while(true) 
....................    {   
....................       int l; //Indice para parpadeo led estado. 
....................       int t; //Indice para varias medidas de temperatura. 
....................        
....................       //Led de estado. 
....................        for (l=0;l<2;l++){ 
0AB8:  BSF    03.5
0AB9:  CLRF   3F
0ABA:  MOVF   3F,W
0ABB:  SUBLW  01
0ABC:  BTFSS  03.0
0ABD:  GOTO   2E2
....................         output_low(PIN_C0); 
0ABE:  BCF    03.5
0ABF:  BCF    36.0
0AC0:  MOVF   36,W
0AC1:  BSF    03.5
0AC2:  MOVWF  07
0AC3:  BCF    03.5
0AC4:  BCF    07.0
....................         delay_ms(200);          
0AC5:  MOVLW  C8
0AC6:  BSF    03.5
0AC7:  MOVWF  42
0AC8:  BCF    0A.3
0AC9:  BCF    03.5
0ACA:  CALL   2F3
0ACB:  BSF    0A.3
....................         output_high(PIN_C0); 
0ACC:  BCF    36.0
0ACD:  MOVF   36,W
0ACE:  BSF    03.5
0ACF:  MOVWF  07
0AD0:  BCF    03.5
0AD1:  BSF    07.0
....................         delay_ms(200); 
0AD2:  MOVLW  C8
0AD3:  BSF    03.5
0AD4:  MOVWF  42
0AD5:  BCF    0A.3
0AD6:  BCF    03.5
0AD7:  CALL   2F3
0AD8:  BSF    0A.3
....................         output_low(PIN_C0);} 
0AD9:  BCF    36.0
0ADA:  MOVF   36,W
0ADB:  BSF    03.5
0ADC:  MOVWF  07
0ADD:  BCF    03.5
0ADE:  BCF    07.0
0ADF:  BSF    03.5
0AE0:  INCF   3F,F
0AE1:  GOTO   2BA
....................         delay_ms(2000); 
0AE2:  MOVLW  08
0AE3:  MOVWF  41
0AE4:  MOVLW  FA
0AE5:  MOVWF  42
0AE6:  BCF    0A.3
0AE7:  BCF    03.5
0AE8:  CALL   2F3
0AE9:  BSF    0A.3
0AEA:  BSF    03.5
0AEB:  DECFSZ 41,F
0AEC:  GOTO   2E4
....................        
....................       //LECTURA DE SENSORES.       
....................         set_adc_channel(1); //Selección del canal analógico. 
0AED:  MOVLW  08
0AEE:  MOVWF  78
0AEF:  BCF    03.5
0AF0:  MOVF   1F,W
0AF1:  ANDLW  C7
0AF2:  IORWF  78,W
0AF3:  MOVWF  1F
....................         delay_us (20); 
0AF4:  MOVLW  06
0AF5:  MOVWF  77
0AF6:  DECFSZ 77,F
0AF7:  GOTO   2F6
0AF8:  NOP
....................         temperatura=0.0; 
0AF9:  CLRF   65
0AFA:  CLRF   64
0AFB:  CLRF   63
0AFC:  CLRF   62
....................          
....................         //Varias medidas para sacar una media de la temperatura. 
....................         for (t=0;t<6;t++){ 
0AFD:  BSF    03.5
0AFE:  CLRF   40
0AFF:  MOVF   40,W
0B00:  SUBLW  05
0B01:  BTFSS  03.0
0B02:  GOTO   340
....................          temperatura = temperatura + read_adc(); 
0B03:  BCF    03.5
0B04:  BSF    1F.2
0B05:  BTFSC  1F.2
0B06:  GOTO   305
0B07:  MOVF   1E,W
0B08:  MOVWF  7A
0B09:  BSF    03.5
0B0A:  MOVF   1E,W
0B0B:  MOVWF  41
0B0C:  MOVF   7A,W
0B0D:  MOVWF  42
0B0E:  BCF    0A.3
0B0F:  BCF    03.5
0B10:  GOTO   33B
0B11:  BSF    0A.3
0B12:  BCF    03.1
0B13:  MOVF   65,W
0B14:  BSF    03.5
0B15:  MOVWF  44
0B16:  BCF    03.5
0B17:  MOVF   64,W
0B18:  BSF    03.5
0B19:  MOVWF  43
0B1A:  BCF    03.5
0B1B:  MOVF   63,W
0B1C:  BSF    03.5
0B1D:  MOVWF  42
0B1E:  BCF    03.5
0B1F:  MOVF   62,W
0B20:  BSF    03.5
0B21:  MOVWF  41
0B22:  MOVF   7A,W
0B23:  MOVWF  48
0B24:  MOVF   79,W
0B25:  MOVWF  47
0B26:  MOVF   78,W
0B27:  MOVWF  46
0B28:  MOVF   77,W
0B29:  MOVWF  45
0B2A:  BCF    0A.3
0B2B:  BCF    03.5
0B2C:  CALL   35C
0B2D:  BSF    0A.3
0B2E:  MOVF   7A,W
0B2F:  MOVWF  65
0B30:  MOVF   79,W
0B31:  MOVWF  64
0B32:  MOVF   78,W
0B33:  MOVWF  63
0B34:  MOVF   77,W
0B35:  MOVWF  62
....................          delay_ms(10);         
0B36:  MOVLW  0A
0B37:  BSF    03.5
0B38:  MOVWF  42
0B39:  BCF    0A.3
0B3A:  BCF    03.5
0B3B:  CALL   2F3
0B3C:  BSF    0A.3
....................         } 
0B3D:  BSF    03.5
0B3E:  INCF   40,F
0B3F:  GOTO   2FF
....................         temperatura = (temperatura/1);        
0B40:  BCF    03.5
0B41:  MOVF   65,W
0B42:  BSF    03.5
0B43:  MOVWF  44
0B44:  BCF    03.5
0B45:  MOVF   64,W
0B46:  BSF    03.5
0B47:  MOVWF  43
0B48:  BCF    03.5
0B49:  MOVF   63,W
0B4A:  BSF    03.5
0B4B:  MOVWF  42
0B4C:  BCF    03.5
0B4D:  MOVF   62,W
0B4E:  BSF    03.5
0B4F:  MOVWF  41
0B50:  CLRF   48
0B51:  CLRF   47
0B52:  CLRF   46
0B53:  MOVLW  7F
0B54:  MOVWF  45
0B55:  BCF    0A.3
0B56:  BCF    03.5
0B57:  CALL   4A2
0B58:  BSF    0A.3
0B59:  MOVF   7A,W
0B5A:  MOVWF  65
0B5B:  MOVF   79,W
0B5C:  MOVWF  64
0B5D:  MOVF   78,W
0B5E:  MOVWF  63
0B5F:  MOVF   77,W
0B60:  MOVWF  62
....................         delay_ms(1); 
0B61:  MOVLW  01
0B62:  BSF    03.5
0B63:  MOVWF  42
0B64:  BCF    0A.3
0B65:  BCF    03.5
0B66:  CALL   2F3
0B67:  BSF    0A.3
....................          
....................         //Led de estado. 
....................        for (l=0;l<2;l++){ 
0B68:  BSF    03.5
0B69:  CLRF   3F
0B6A:  MOVF   3F,W
0B6B:  SUBLW  01
0B6C:  BTFSS  03.0
0B6D:  GOTO   392
....................         output_low(PIN_C0); 
0B6E:  BCF    03.5
0B6F:  BCF    36.0
0B70:  MOVF   36,W
0B71:  BSF    03.5
0B72:  MOVWF  07
0B73:  BCF    03.5
0B74:  BCF    07.0
....................         delay_ms(200);          
0B75:  MOVLW  C8
0B76:  BSF    03.5
0B77:  MOVWF  42
0B78:  BCF    0A.3
0B79:  BCF    03.5
0B7A:  CALL   2F3
0B7B:  BSF    0A.3
....................         output_high(PIN_C0); 
0B7C:  BCF    36.0
0B7D:  MOVF   36,W
0B7E:  BSF    03.5
0B7F:  MOVWF  07
0B80:  BCF    03.5
0B81:  BSF    07.0
....................         delay_ms(200); 
0B82:  MOVLW  C8
0B83:  BSF    03.5
0B84:  MOVWF  42
0B85:  BCF    0A.3
0B86:  BCF    03.5
0B87:  CALL   2F3
0B88:  BSF    0A.3
....................         output_low(PIN_C0); 
0B89:  BCF    36.0
0B8A:  MOVF   36,W
0B8B:  BSF    03.5
0B8C:  MOVWF  07
0B8D:  BCF    03.5
0B8E:  BCF    07.0
....................         } 
0B8F:  BSF    03.5
0B90:  INCF   3F,F
0B91:  GOTO   36A
....................         
....................      //Calculo de la temperatura dada por el sensor MCP9700.  
....................      //ADC configurado a 10 bits. Vcc = 5v. 
....................      temperatura = (temperatura*(5.0/1024.0)); 
0B92:  BCF    03.5
0B93:  MOVF   65,W
0B94:  BSF    03.5
0B95:  MOVWF  51
0B96:  BCF    03.5
0B97:  MOVF   64,W
0B98:  BSF    03.5
0B99:  MOVWF  50
0B9A:  BCF    03.5
0B9B:  MOVF   63,W
0B9C:  BSF    03.5
0B9D:  MOVWF  4F
0B9E:  BCF    03.5
0B9F:  MOVF   62,W
0BA0:  BSF    03.5
0BA1:  MOVWF  4E
0BA2:  CLRF   55
0BA3:  CLRF   54
0BA4:  MOVLW  20
0BA5:  MOVWF  53
0BA6:  MOVLW  77
0BA7:  MOVWF  52
0BA8:  BCF    0A.3
0BA9:  BCF    03.5
0BAA:  CALL   56E
0BAB:  BSF    0A.3
0BAC:  MOVF   7A,W
0BAD:  MOVWF  65
0BAE:  MOVF   79,W
0BAF:  MOVWF  64
0BB0:  MOVF   78,W
0BB1:  MOVWF  63
0BB2:  MOVF   77,W
0BB3:  MOVWF  62
....................      temperatura = temperatura - 0.5; 
0BB4:  BSF    03.1
0BB5:  MOVF   65,W
0BB6:  BSF    03.5
0BB7:  MOVWF  44
0BB8:  BCF    03.5
0BB9:  MOVF   64,W
0BBA:  BSF    03.5
0BBB:  MOVWF  43
0BBC:  BCF    03.5
0BBD:  MOVF   63,W
0BBE:  BSF    03.5
0BBF:  MOVWF  42
0BC0:  BCF    03.5
0BC1:  MOVF   62,W
0BC2:  BSF    03.5
0BC3:  MOVWF  41
0BC4:  CLRF   48
0BC5:  CLRF   47
0BC6:  CLRF   46
0BC7:  MOVLW  7E
0BC8:  MOVWF  45
0BC9:  BCF    0A.3
0BCA:  BCF    03.5
0BCB:  CALL   35C
0BCC:  BSF    0A.3
0BCD:  MOVF   7A,W
0BCE:  MOVWF  65
0BCF:  MOVF   79,W
0BD0:  MOVWF  64
0BD1:  MOVF   78,W
0BD2:  MOVWF  63
0BD3:  MOVF   77,W
0BD4:  MOVWF  62
....................      temperatura = temperatura/0.01; 
0BD5:  MOVF   65,W
0BD6:  BSF    03.5
0BD7:  MOVWF  44
0BD8:  BCF    03.5
0BD9:  MOVF   64,W
0BDA:  BSF    03.5
0BDB:  MOVWF  43
0BDC:  BCF    03.5
0BDD:  MOVF   63,W
0BDE:  BSF    03.5
0BDF:  MOVWF  42
0BE0:  BCF    03.5
0BE1:  MOVF   62,W
0BE2:  BSF    03.5
0BE3:  MOVWF  41
0BE4:  MOVLW  0A
0BE5:  MOVWF  48
0BE6:  MOVLW  D7
0BE7:  MOVWF  47
0BE8:  MOVLW  23
0BE9:  MOVWF  46
0BEA:  MOVLW  78
0BEB:  MOVWF  45
0BEC:  BCF    0A.3
0BED:  BCF    03.5
0BEE:  CALL   4A2
0BEF:  BSF    0A.3
0BF0:  MOVF   7A,W
0BF1:  MOVWF  65
0BF2:  MOVF   79,W
0BF3:  MOVWF  64
0BF4:  MOVF   78,W
0BF5:  MOVWF  63
0BF6:  MOVF   77,W
0BF7:  MOVWF  62
....................       
....................      //Led estado. 
....................     for (l=0;l<3;l++){ 
0BF8:  BSF    03.5
0BF9:  CLRF   3F
0BFA:  MOVF   3F,W
0BFB:  SUBLW  02
0BFC:  BTFSS  03.0
0BFD:  GOTO   422
....................         output_low(PIN_C0); 
0BFE:  BCF    03.5
0BFF:  BCF    36.0
0C00:  MOVF   36,W
0C01:  BSF    03.5
0C02:  MOVWF  07
0C03:  BCF    03.5
0C04:  BCF    07.0
....................         delay_ms(200);          
0C05:  MOVLW  C8
0C06:  BSF    03.5
0C07:  MOVWF  42
0C08:  BCF    0A.3
0C09:  BCF    03.5
0C0A:  CALL   2F3
0C0B:  BSF    0A.3
....................         output_high(PIN_C0); 
0C0C:  BCF    36.0
0C0D:  MOVF   36,W
0C0E:  BSF    03.5
0C0F:  MOVWF  07
0C10:  BCF    03.5
0C11:  BSF    07.0
....................         delay_ms(200); 
0C12:  MOVLW  C8
0C13:  BSF    03.5
0C14:  MOVWF  42
0C15:  BCF    0A.3
0C16:  BCF    03.5
0C17:  CALL   2F3
0C18:  BSF    0A.3
....................         output_low(PIN_C0);} 
0C19:  BCF    36.0
0C1A:  MOVF   36,W
0C1B:  BSF    03.5
0C1C:  MOVWF  07
0C1D:  BCF    03.5
0C1E:  BCF    07.0
0C1F:  BSF    03.5
0C20:  INCF   3F,F
0C21:  GOTO   3FA
....................         delay_ms(2000); 
0C22:  MOVLW  08
0C23:  MOVWF  41
0C24:  MOVLW  FA
0C25:  MOVWF  42
0C26:  BCF    0A.3
0C27:  BCF    03.5
0C28:  CALL   2F3
0C29:  BSF    0A.3
0C2A:  BSF    03.5
0C2B:  DECFSZ 41,F
0C2C:  GOTO   424
....................          
....................      //Conversion float to string. 
....................      sprintf(s,"%2.2f",temperatura); 
*
0A5D:  CLRF   7C
0A5E:  CLRF   7D
*
0C2D:  CLRF   7D
0C2E:  MOVLW  A8
0C2F:  MOVWF  7C
0C30:  MOVLW  89
0C31:  MOVWF  04
0C32:  BCF    03.5
0C33:  MOVF   65,W
0C34:  BSF    03.5
0C35:  MOVWF  44
0C36:  BCF    03.5
0C37:  MOVF   64,W
0C38:  BSF    03.5
0C39:  MOVWF  43
0C3A:  BCF    03.5
0C3B:  MOVF   63,W
0C3C:  BSF    03.5
0C3D:  MOVWF  42
0C3E:  BCF    03.5
0C3F:  MOVF   62,W
0C40:  BSF    03.5
0C41:  MOVWF  41
0C42:  MOVLW  02
0C43:  MOVWF  45
0C44:  BCF    0A.3
0C45:  BCF    03.5
0C46:  GOTO   638
0C47:  BSF    0A.3
....................       
....................      // Cargo informacion al frame para ser enviada. 
....................      for (g=0;g<8;g++){ 
0C48:  BSF    03.5
0C49:  CLRF   3D
0C4A:  MOVF   3D,W
0C4B:  SUBLW  07
0C4C:  BTFSS  03.0
0C4D:  GOTO   468
....................             Buff[g] = ident[g];      
0C4E:  MOVLW  41
0C4F:  ADDWF  3D,W
0C50:  MOVWF  78
0C51:  CLRF   7A
0C52:  BTFSC  03.0
0C53:  INCF   7A,F
0C54:  MOVF   78,W
0C55:  MOVWF  41
0C56:  MOVF   7A,W
0C57:  MOVWF  42
0C58:  BCF    03.0
0C59:  RLF    3D,W
0C5A:  ADDLW  66
0C5B:  MOVWF  04
0C5C:  BCF    03.7
0C5D:  MOVF   00,W
0C5E:  MOVWF  43
0C5F:  MOVF   41,W
0C60:  MOVWF  04
0C61:  BCF    03.7
0C62:  BTFSC  42.0
0C63:  BSF    03.7
0C64:  MOVF   43,W
0C65:  MOVWF  00
....................      } 
0C66:  INCF   3D,F
0C67:  GOTO   44A
....................       
....................      for (g=8;g<21;g++) 
0C68:  MOVLW  08
0C69:  MOVWF  3D
0C6A:  MOVF   3D,W
0C6B:  SUBLW  14
0C6C:  BTFSS  03.0
0C6D:  GOTO   487
....................          {          
....................             Buff[g] = frase[g];            
0C6E:  MOVLW  41
0C6F:  ADDWF  3D,W
0C70:  MOVWF  78
0C71:  CLRF   7A
0C72:  BTFSC  03.0
0C73:  INCF   7A,F
0C74:  MOVF   78,W
0C75:  MOVWF  41
0C76:  MOVF   7A,W
0C77:  MOVWF  42
0C78:  MOVLW  AF
0C79:  ADDWF  3D,W
0C7A:  MOVWF  04
0C7B:  BCF    03.7
0C7C:  MOVF   00,W
0C7D:  MOVWF  43
0C7E:  MOVF   41,W
0C7F:  MOVWF  04
0C80:  BCF    03.7
0C81:  BTFSC  42.0
0C82:  BSF    03.7
0C83:  MOVF   43,W
0C84:  MOVWF  00
....................          } 
0C85:  INCF   3D,F
0C86:  GOTO   46A
....................          g++; 
0C87:  INCF   3D,F
....................       for (gg=0;gg<7;gg++) 
0C88:  CLRF   3E
0C89:  MOVF   3E,W
0C8A:  SUBLW  06
0C8B:  BTFSS  03.0
0C8C:  GOTO   4A7
....................          {          
....................             Buff[g] = s[gg]; 
0C8D:  MOVLW  41
0C8E:  ADDWF  3D,W
0C8F:  MOVWF  78
0C90:  CLRF   7A
0C91:  BTFSC  03.0
0C92:  INCF   7A,F
0C93:  MOVF   78,W
0C94:  MOVWF  41
0C95:  MOVF   7A,W
0C96:  MOVWF  42
0C97:  MOVLW  A8
0C98:  ADDWF  3E,W
0C99:  MOVWF  04
0C9A:  BCF    03.7
0C9B:  MOVF   00,W
0C9C:  MOVWF  43
0C9D:  MOVF   41,W
0C9E:  MOVWF  04
0C9F:  BCF    03.7
0CA0:  BTFSC  42.0
0CA1:  BSF    03.7
0CA2:  MOVF   43,W
0CA3:  MOVWF  00
....................             g++; 
0CA4:  INCF   3D,F
....................          } 
0CA5:  INCF   3E,F
0CA6:  GOTO   489
....................        
....................       Send_frame(); //Envio el frame por RF. 
0CA7:  BCF    03.5
0CA8:  GOTO   000
....................        
....................       //Tiempo de espera. 
....................       Delay_ms(10000); 
0CA9:  MOVLW  28
0CAA:  BSF    03.5
0CAB:  MOVWF  41
0CAC:  MOVLW  FA
0CAD:  MOVWF  42
0CAE:  BCF    0A.3
0CAF:  BCF    03.5
0CB0:  CALL   2F3
0CB1:  BSF    0A.3
0CB2:  BSF    03.5
0CB3:  DECFSZ 41,F
0CB4:  GOTO   4AC
....................           
....................    } 
0CB5:  GOTO   2B9
.................... } 
0CB6:  SLEEP

Configuration Fuses:
   Word  1: 3F31   XT NOWDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
