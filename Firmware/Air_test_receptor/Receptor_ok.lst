CCS PCM C Compiler, Version 4.057, 32216               13-abr-14 23:48

               Filename: C:\Users\Core\Dropbox\Codigo_ccsc\Air_test_receptor\Receptor_ok.lst

               ROM used: 4163 words (51%)
                         Largest free fragment is 2048
               RAM used: 78 (21%) at main() level
                         127 (35%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   380
.................... #include <16F876A.h> 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #FUSES NOWDT, XT, PUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=4000000) 
*
05D1:  MOVLW  68
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  MOVF   00,W
05D5:  BTFSC  03.2
05D6:  GOTO   5E5
05D7:  MOVLW  01
05D8:  MOVWF  78
05D9:  CLRF   77
05DA:  DECFSZ 77,F
05DB:  GOTO   5DA
05DC:  DECFSZ 78,F
05DD:  GOTO   5D9
05DE:  MOVLW  4A
05DF:  MOVWF  77
05E0:  DECFSZ 77,F
05E1:  GOTO   5E0
05E2:  GOTO   5E3
05E3:  DECFSZ 00,F
05E4:  GOTO   5D7
05E5:  RETLW  00
.................... #use rs232(baud=9600, xmit=pin_C6, rcv=pin_C7) 
....................  
.................... #include "lib_rf2gh4_10.h" 
.................... //******************************************************************************** 
.................... //*    lib_rf2gh4_10.h                                                           * 
.................... //*     version: 1.0                                                             * 
.................... //*     Esta librería contiene las funciones necesarias para gestionar el módulo * 
.................... //*    RF2GH4 con programas del compilador CCS                                   * 
.................... //*    Copyright (C) 2007  Bizintek Innova S.L.                                  * 
.................... //******************************************************************************** 
.................... //*    This program is free software; you can redistribute it and/or modify      * 
.................... //*    it under the terms of the GNU General Public License as published by      * 
.................... //*    the Free Software Foundation; either version 2 of the License, or         * 
.................... //*    (at your option) any later version.                                       * 
.................... //*                                                                              * 
.................... //*    This program is distributed in the hope that it will be useful,           * 
.................... //*    but WITHOUT ANY WARRANTY; without even the implied warranty of            * 
.................... //*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             * 
.................... //*    GNU General Public License for more details.                              * 
.................... //*                                                                              * 
.................... //*    You should have received a copy of the GNU General Public License along   * 
.................... //*    with this program; if not, write to the Free Software Foundation, Inc.,   * 
.................... //*    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               * 
.................... //******************************************************************************** 
....................  
....................  
.................... //******************** 
.................... //*   DEFINICIONES   * 
.................... //******************** 
....................  
.................... // PORTB 
.................... #define RF_IRQ        PIN_B0 
.................... #define RF_IRQ_TRIS   TRISB,0 
....................  
.................... // PORTC 
.................... #define   RF_CS       PIN_C1 
.................... #define   RF_CE       PIN_C2 
.................... #define   SCK         PIN_C3 
.................... #define   SDI         PIN_C4 
.................... #define   SDO         PIN_C5 
....................                        
.................... #define   RF_CS_TRIS  TRISC,1 
.................... #define   RF_CE_TRIS  TRISC,2 
.................... #define   SCK_TRIS    TRISC,3 
.................... #define   SDI_TRIS    TRISC,4 
.................... #define   SDO_TRIS    TRISC,5 
....................  
....................  
....................  
.................... //***************** 
.................... //*   VARIABLES   * 
.................... //***************** 
.................... #BYTE TRISA     =  0x85 
.................... #BYTE TRISB     =  0x86 
.................... #BYTE TRISC     =  0x87 
.................... #BYTE INTCON    =  0x0B 
....................  
.................... //Variables internas 
.................... static int1        interRF; 
*
1013:  BCF    03.5
1014:  BCF    29.0
.................... static int16       noRF; 
1015:  CLRF   2A
1016:  CLRF   2B
.................... static int1        RCVNW=0; 
1017:  BCF    29.1
.................... static int8        DATA_N_SND=0; 
1018:  CLRF   2C
.................... static int8        DATA_N_RCV=0; 
1019:  CLRF   2D
....................  
.................... //Variables configurables 
.................... static int8        RF_DATA[8]; 
101A:  CLRF   2E
101B:  CLRF   2F
101C:  CLRF   30
101D:  CLRF   31
101E:  CLRF   32
101F:  CLRF   33
1020:  CLRF   34
1021:  CLRF   35
.................... static int8        RF_DIR; 
1022:  CLRF   36
....................  
....................  
.................... //************** 
.................... //*   CÓDIGO   * 
.................... //************** 
....................  
.................... //***************************************************** 
.................... //*               RF_CONFIG_SPI()                     * 
.................... //***************************************************** 
.................... //*Descripción: La función configura el módulo SPI del* 
.................... //*microcontrolador.En ella se especifica como salida * 
.................... //*SDO y como entrada SDI entre otros parámetros del  * 
.................... //*protocolo SPI.                                     * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_CONFIG_SPI() 
.................... { 
....................    //Configuración I/O. 
....................    bit_clear(SCK_TRIS); 
*
03E8:  BSF    03.5
03E9:  BCF    07.3
....................    bit_set(SDI_TRIS); 
03EA:  BSF    07.4
....................    bit_clear(SDO_TRIS); 
03EB:  BCF    07.5
....................  
....................    //Configuración módulo comunicaciones. 
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_XMIT_L_TO_H 
....................    |SPI_CLK_DIV_4|SPI_SAMPLE_AT_END); 
03EC:  BCF    03.5
03ED:  BCF    14.5
03EE:  BCF    37.5
03EF:  MOVF   37,W
03F0:  BSF    03.5
03F1:  MOVWF  07
03F2:  BCF    03.5
03F3:  BSF    37.4
03F4:  MOVF   37,W
03F5:  BSF    03.5
03F6:  MOVWF  07
03F7:  BCF    03.5
03F8:  BCF    37.3
03F9:  MOVF   37,W
03FA:  BSF    03.5
03FB:  MOVWF  07
03FC:  MOVLW  20
03FD:  BCF    03.5
03FE:  MOVWF  14
03FF:  MOVLW  C0
0400:  BSF    03.5
0401:  MOVWF  14
*
1023:  MOVLW  FF
1024:  MOVWF  37
.................... } 
*
0402:  BCF    03.5
0403:  BCF    0A.3
0404:  BSF    0A.4
0405:  GOTO   03C (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                    RF_INT_EN()                    * 
.................... //***************************************************** 
.................... //*Descripción:Se encarga de habilitar la interrupción* 
.................... //*externa (RB0) utilizada por el módulo de RF en la  * 
.................... //*recepción de datos.                                * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_INT_EN() 
.................... { 
....................    //Habilitar interrupciones externas con flanco de 
....................    //bajada. 
....................    disable_interrupts(global); 
*
03DA:  BCF    0B.6
03DB:  BCF    0B.7
03DC:  BTFSC  0B.7
03DD:  GOTO   3DB
....................    enable_interrupts(int_ext); 
03DE:  BSF    0B.4
....................    ext_int_edge( H_TO_L ); 
03DF:  BSF    03.5
03E0:  BCF    01.6
....................    bit_set(RF_IRQ_TRIS); 
03E1:  BSF    06.0
....................    enable_interrupts(global); 
03E2:  MOVLW  C0
03E3:  BCF    03.5
03E4:  IORWF  0B,F
.................... } 
03E5:  BCF    0A.3
03E6:  BSF    0A.4
03E7:  GOTO   039 (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*        RF_CONFIG(int canal, int dir)              * 
.................... //***************************************************** 
.................... //*Descripción:Esta función se encarga de configurar  * 
.................... //*el transceptor habilitando su propia dirección de  * 
.................... //*escucha y el canal entre otros parámetros.         * 
.................... //***************************************************** 
.................... //*Variables de entrada:- Canal                       * 
.................... //*                     - Direccion                   * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_CONFIG(int canal, int dir) 
.................... { 
....................  
....................    bit_clear(RF_CS_TRIS); 
*
0406:  BSF    03.5
0407:  BCF    07.1
....................    bit_set(RF_IRQ_TRIS); 
0408:  BSF    06.0
....................    bit_clear(RF_CE_TRIS); 
0409:  BCF    07.2
....................  
....................    output_low(RF_CE); 
040A:  BCF    03.5
040B:  BCF    37.2
040C:  MOVF   37,W
040D:  BSF    03.5
040E:  MOVWF  07
040F:  BCF    03.5
0410:  BCF    07.2
....................  
....................    // TX_ADDR (0xFF) 
....................    //Configuración de la dirección de envio aleatoria. 
....................    //En la función de enviar se configura la direccion 
....................    //deseada por el usuario. 
....................    output_low(RF_CS); 
0411:  BCF    37.1
0412:  MOVF   37,W
0413:  BSF    03.5
0414:  MOVWF  07
0415:  BCF    03.5
0416:  BCF    07.1
....................    spi_write(0x30); 
0417:  MOVF   13,W
0418:  MOVLW  30
0419:  MOVWF  13
041A:  BSF    03.5
041B:  BTFSS  14.0
041C:  GOTO   41B
....................    spi_write(0xFF); 
041D:  BCF    03.5
041E:  MOVF   13,W
041F:  MOVLW  FF
0420:  MOVWF  13
0421:  BSF    03.5
0422:  BTFSS  14.0
0423:  GOTO   422
....................    spi_write(0xC2); 
0424:  BCF    03.5
0425:  MOVF   13,W
0426:  MOVLW  C2
0427:  MOVWF  13
0428:  BSF    03.5
0429:  BTFSS  14.0
042A:  GOTO   429
....................    spi_write(0xC2); 
042B:  BCF    03.5
042C:  MOVF   13,W
042D:  MOVLW  C2
042E:  MOVWF  13
042F:  BSF    03.5
0430:  BTFSS  14.0
0431:  GOTO   430
....................    spi_write(0xC2); 
0432:  BCF    03.5
0433:  MOVF   13,W
0434:  MOVLW  C2
0435:  MOVWF  13
0436:  BSF    03.5
0437:  BTFSS  14.0
0438:  GOTO   437
....................    spi_write(0xC2); 
0439:  BCF    03.5
043A:  MOVF   13,W
043B:  MOVLW  C2
043C:  MOVWF  13
043D:  BSF    03.5
043E:  BTFSS  14.0
043F:  GOTO   43E
....................    output_high(RF_CS); 
0440:  BCF    03.5
0441:  BCF    37.1
0442:  MOVF   37,W
0443:  BSF    03.5
0444:  MOVWF  07
0445:  BCF    03.5
0446:  BSF    07.1
....................  
....................    // RX_ADDR_P0 (0xFF) ACK 
....................    //Configuración de la direccióndel Pipe0 para la 
....................    //recepción de ACK. 
....................    output_low(RF_CS); 
0447:  BCF    37.1
0448:  MOVF   37,W
0449:  BSF    03.5
044A:  MOVWF  07
044B:  BCF    03.5
044C:  BCF    07.1
....................    spi_write(0x2A); 
044D:  MOVF   13,W
044E:  MOVLW  2A
044F:  MOVWF  13
0450:  BSF    03.5
0451:  BTFSS  14.0
0452:  GOTO   451
....................    spi_write(0xFF); 
0453:  BCF    03.5
0454:  MOVF   13,W
0455:  MOVLW  FF
0456:  MOVWF  13
0457:  BSF    03.5
0458:  BTFSS  14.0
0459:  GOTO   458
....................    spi_write(0xC2); 
045A:  BCF    03.5
045B:  MOVF   13,W
045C:  MOVLW  C2
045D:  MOVWF  13
045E:  BSF    03.5
045F:  BTFSS  14.0
0460:  GOTO   45F
....................    spi_write(0xC2); 
0461:  BCF    03.5
0462:  MOVF   13,W
0463:  MOVLW  C2
0464:  MOVWF  13
0465:  BSF    03.5
0466:  BTFSS  14.0
0467:  GOTO   466
....................    spi_write(0xC2); 
0468:  BCF    03.5
0469:  MOVF   13,W
046A:  MOVLW  C2
046B:  MOVWF  13
046C:  BSF    03.5
046D:  BTFSS  14.0
046E:  GOTO   46D
....................    spi_write(0xC2); 
046F:  BCF    03.5
0470:  MOVF   13,W
0471:  MOVLW  C2
0472:  MOVWF  13
0473:  BSF    03.5
0474:  BTFSS  14.0
0475:  GOTO   474
....................    output_high(RF_CS); 
0476:  BCF    03.5
0477:  BCF    37.1
0478:  MOVF   37,W
0479:  BSF    03.5
047A:  MOVWF  07
047B:  BCF    03.5
047C:  BSF    07.1
....................  
....................    // RX_ADDR_P1 (dir) 
....................    //Configuración de la direccióndel Pipe1 para la 
....................    //recepción de tramas. 
....................    output_low(RF_CS); 
047D:  BCF    37.1
047E:  MOVF   37,W
047F:  BSF    03.5
0480:  MOVWF  07
0481:  BCF    03.5
0482:  BCF    07.1
....................    spi_write(0x2B); 
0483:  MOVF   13,W
0484:  MOVLW  2B
0485:  MOVWF  13
0486:  BSF    03.5
0487:  BTFSS  14.0
0488:  GOTO   487
....................    spi_write(dir); 
0489:  BCF    03.5
048A:  MOVF   68,W
048B:  MOVWF  13
048C:  BSF    03.5
048D:  BTFSS  14.0
048E:  GOTO   48D
....................    spi_write(0xC2); 
048F:  BCF    03.5
0490:  MOVF   13,W
0491:  MOVLW  C2
0492:  MOVWF  13
0493:  BSF    03.5
0494:  BTFSS  14.0
0495:  GOTO   494
....................    spi_write(0xC2); 
0496:  BCF    03.5
0497:  MOVF   13,W
0498:  MOVLW  C2
0499:  MOVWF  13
049A:  BSF    03.5
049B:  BTFSS  14.0
049C:  GOTO   49B
....................    spi_write(0xC2); 
049D:  BCF    03.5
049E:  MOVF   13,W
049F:  MOVLW  C2
04A0:  MOVWF  13
04A1:  BSF    03.5
04A2:  BTFSS  14.0
04A3:  GOTO   4A2
....................    spi_write(0xC2); 
04A4:  BCF    03.5
04A5:  MOVF   13,W
04A6:  MOVLW  C2
04A7:  MOVWF  13
04A8:  BSF    03.5
04A9:  BTFSS  14.0
04AA:  GOTO   4A9
....................    output_high(RF_CS); 
04AB:  BCF    03.5
04AC:  BCF    37.1
04AD:  MOVF   37,W
04AE:  BSF    03.5
04AF:  MOVWF  07
04B0:  BCF    03.5
04B1:  BSF    07.1
....................  
....................    // RX_ADDR_P2 (0x00) BROADCAST 
....................    //Configuración de la direccióndel Pipe2 para la 
....................    //recepción de tramas 
....................    output_low(RF_CS); 
04B2:  BCF    37.1
04B3:  MOVF   37,W
04B4:  BSF    03.5
04B5:  MOVWF  07
04B6:  BCF    03.5
04B7:  BCF    07.1
....................    spi_write(0x2C); 
04B8:  MOVF   13,W
04B9:  MOVLW  2C
04BA:  MOVWF  13
04BB:  BSF    03.5
04BC:  BTFSS  14.0
04BD:  GOTO   4BC
....................    spi_write(0x00); 
04BE:  BCF    03.5
04BF:  MOVF   13,W
04C0:  CLRF   13
04C1:  BSF    03.5
04C2:  BTFSS  14.0
04C3:  GOTO   4C2
....................    output_high(RF_CS); 
04C4:  BCF    03.5
04C5:  BCF    37.1
04C6:  MOVF   37,W
04C7:  BSF    03.5
04C8:  MOVWF  07
04C9:  BCF    03.5
04CA:  BSF    07.1
....................  
....................    // EN_AA 
....................    //Habilitar AutoAck en los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
04CB:  BCF    37.1
04CC:  MOVF   37,W
04CD:  BSF    03.5
04CE:  MOVWF  07
04CF:  BCF    03.5
04D0:  BCF    07.1
....................    spi_write(0x21); 
04D1:  MOVF   13,W
04D2:  MOVLW  21
04D3:  MOVWF  13
04D4:  BSF    03.5
04D5:  BTFSS  14.0
04D6:  GOTO   4D5
....................    spi_write(0x07); 
04D7:  BCF    03.5
04D8:  MOVF   13,W
04D9:  MOVLW  07
04DA:  MOVWF  13
04DB:  BSF    03.5
04DC:  BTFSS  14.0
04DD:  GOTO   4DC
....................    output_high(RF_CS); 
04DE:  BCF    03.5
04DF:  BCF    37.1
04E0:  MOVF   37,W
04E1:  BSF    03.5
04E2:  MOVWF  07
04E3:  BCF    03.5
04E4:  BSF    07.1
....................  
....................    // EN_RXADDR 
....................    //Habilitar los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
04E5:  BCF    37.1
04E6:  MOVF   37,W
04E7:  BSF    03.5
04E8:  MOVWF  07
04E9:  BCF    03.5
04EA:  BCF    07.1
....................    spi_write(0x22); 
04EB:  MOVF   13,W
04EC:  MOVLW  22
04ED:  MOVWF  13
04EE:  BSF    03.5
04EF:  BTFSS  14.0
04F0:  GOTO   4EF
....................    spi_write(0x07); 
04F1:  BCF    03.5
04F2:  MOVF   13,W
04F3:  MOVLW  07
04F4:  MOVWF  13
04F5:  BSF    03.5
04F6:  BTFSS  14.0
04F7:  GOTO   4F6
....................    output_high(RF_CS); 
04F8:  BCF    03.5
04F9:  BCF    37.1
04FA:  MOVF   37,W
04FB:  BSF    03.5
04FC:  MOVWF  07
04FD:  BCF    03.5
04FE:  BSF    07.1
....................  
....................    // SETUP_AW 
....................    //Configuración de la longitud de las direcciones. 
....................    //Direcciones de 5 bytes. 
....................    output_low(RF_CS); 
04FF:  BCF    37.1
0500:  MOVF   37,W
0501:  BSF    03.5
0502:  MOVWF  07
0503:  BCF    03.5
0504:  BCF    07.1
....................    spi_write(0x23); 
0505:  MOVF   13,W
0506:  MOVLW  23
0507:  MOVWF  13
0508:  BSF    03.5
0509:  BTFSS  14.0
050A:  GOTO   509
....................    spi_write(0x03); 
050B:  BCF    03.5
050C:  MOVF   13,W
050D:  MOVLW  03
050E:  MOVWF  13
050F:  BSF    03.5
0510:  BTFSS  14.0
0511:  GOTO   510
....................    output_high(RF_CS); 
0512:  BCF    03.5
0513:  BCF    37.1
0514:  MOVF   37,W
0515:  BSF    03.5
0516:  MOVWF  07
0517:  BCF    03.5
0518:  BSF    07.1
....................  
....................    //SETUP_RETR 
....................    //Configuración de las retrasmisiones en la transmisión. 
....................    //Diez retransmisiones cada 336us. 
....................    output_low(RF_CS); 
0519:  BCF    37.1
051A:  MOVF   37,W
051B:  BSF    03.5
051C:  MOVWF  07
051D:  BCF    03.5
051E:  BCF    07.1
....................    spi_write(0x24); 
051F:  MOVF   13,W
0520:  MOVLW  24
0521:  MOVWF  13
0522:  BSF    03.5
0523:  BTFSS  14.0
0524:  GOTO   523
....................    spi_write(0x0A); 
0525:  BCF    03.5
0526:  MOVF   13,W
0527:  MOVLW  0A
0528:  MOVWF  13
0529:  BSF    03.5
052A:  BTFSS  14.0
052B:  GOTO   52A
....................    output_high(RF_CS); 
052C:  BCF    03.5
052D:  BCF    37.1
052E:  MOVF   37,W
052F:  BSF    03.5
0530:  MOVWF  07
0531:  BCF    03.5
0532:  BSF    07.1
....................  
....................    //RF_CH 
....................    //Configuración del canal. 
....................    //Canal elegido por el usuario (0x01 - 0x7F). 
....................    output_low(RF_CS); 
0533:  BCF    37.1
0534:  MOVF   37,W
0535:  BSF    03.5
0536:  MOVWF  07
0537:  BCF    03.5
0538:  BCF    07.1
....................    spi_write(0x25); 
0539:  MOVF   13,W
053A:  MOVLW  25
053B:  MOVWF  13
053C:  BSF    03.5
053D:  BTFSS  14.0
053E:  GOTO   53D
....................    spi_write(canal); 
053F:  BCF    03.5
0540:  MOVF   67,W
0541:  MOVWF  13
0542:  BSF    03.5
0543:  BTFSS  14.0
0544:  GOTO   543
....................    output_high(RF_CS); 
0545:  BCF    03.5
0546:  BCF    37.1
0547:  MOVF   37,W
0548:  BSF    03.5
0549:  MOVWF  07
054A:  BCF    03.5
054B:  BSF    07.1
....................  
....................    //RF_SETUP 
....................    //Configuración aspectos RF. 
....................    //Ganancia máxima de LNA, 0dBm potencia de salida y 1Mbps de velocidad. 
....................    output_low(RF_CS); 
054C:  BCF    37.1
054D:  MOVF   37,W
054E:  BSF    03.5
054F:  MOVWF  07
0550:  BCF    03.5
0551:  BCF    07.1
....................    spi_write(0x26); 
0552:  MOVF   13,W
0553:  MOVLW  26
0554:  MOVWF  13
0555:  BSF    03.5
0556:  BTFSS  14.0
0557:  GOTO   556
....................    spi_write(0x07); 
0558:  BCF    03.5
0559:  MOVF   13,W
055A:  MOVLW  07
055B:  MOVWF  13
055C:  BSF    03.5
055D:  BTFSS  14.0
055E:  GOTO   55D
....................    output_high(RF_CS); 
055F:  BCF    03.5
0560:  BCF    37.1
0561:  MOVF   37,W
0562:  BSF    03.5
0563:  MOVWF  07
0564:  BCF    03.5
0565:  BSF    07.1
....................  
....................    //STATUS 
....................    //Reseteo del registro STATUS 
....................    output_low(RF_CS); 
0566:  BCF    37.1
0567:  MOVF   37,W
0568:  BSF    03.5
0569:  MOVWF  07
056A:  BCF    03.5
056B:  BCF    07.1
....................    spi_write(0x27); 
056C:  MOVF   13,W
056D:  MOVLW  27
056E:  MOVWF  13
056F:  BSF    03.5
0570:  BTFSS  14.0
0571:  GOTO   570
....................    spi_write(0x70); 
0572:  BCF    03.5
0573:  MOVF   13,W
0574:  MOVLW  70
0575:  MOVWF  13
0576:  BSF    03.5
0577:  BTFSS  14.0
0578:  GOTO   577
....................    output_high(RF_CS); 
0579:  BCF    03.5
057A:  BCF    37.1
057B:  MOVF   37,W
057C:  BSF    03.5
057D:  MOVWF  07
057E:  BCF    03.5
057F:  BSF    07.1
....................  
....................    //RX_PW_P0 
....................    //Nº de bytes en Pipe0. 
....................    //1 byte (ACK). 
....................    output_low(RF_CS); 
0580:  BCF    37.1
0581:  MOVF   37,W
0582:  BSF    03.5
0583:  MOVWF  07
0584:  BCF    03.5
0585:  BCF    07.1
....................    spi_write(0x31); 
0586:  MOVF   13,W
0587:  MOVLW  31
0588:  MOVWF  13
0589:  BSF    03.5
058A:  BTFSS  14.0
058B:  GOTO   58A
....................    spi_write(0x01); 
058C:  BCF    03.5
058D:  MOVF   13,W
058E:  MOVLW  01
058F:  MOVWF  13
0590:  BSF    03.5
0591:  BTFSS  14.0
0592:  GOTO   591
....................    output_high(RF_CS); 
0593:  BCF    03.5
0594:  BCF    37.1
0595:  MOVF   37,W
0596:  BSF    03.5
0597:  MOVWF  07
0598:  BCF    03.5
0599:  BSF    07.1
....................  
....................    //RX_PW_P1 
....................    //Nº de bytes en Pipe1. 
....................    //10 byte (Direccion emisor y trama). 
....................    output_low(RF_CS); 
059A:  BCF    37.1
059B:  MOVF   37,W
059C:  BSF    03.5
059D:  MOVWF  07
059E:  BCF    03.5
059F:  BCF    07.1
....................    spi_write(0x32); 
05A0:  MOVF   13,W
05A1:  MOVLW  32
05A2:  MOVWF  13
05A3:  BSF    03.5
05A4:  BTFSS  14.0
05A5:  GOTO   5A4
....................    spi_write(0x0A); 
05A6:  BCF    03.5
05A7:  MOVF   13,W
05A8:  MOVLW  0A
05A9:  MOVWF  13
05AA:  BSF    03.5
05AB:  BTFSS  14.0
05AC:  GOTO   5AB
....................    output_high(RF_CS); 
05AD:  BCF    03.5
05AE:  BCF    37.1
05AF:  MOVF   37,W
05B0:  BSF    03.5
05B1:  MOVWF  07
05B2:  BCF    03.5
05B3:  BSF    07.1
....................  
....................    //RX_PW_P2 
....................    //Nº de bytes en Pipe2. 
....................    //10 byte (Direccion emisor y trama). 
....................    output_low(RF_CS); 
05B4:  BCF    37.1
05B5:  MOVF   37,W
05B6:  BSF    03.5
05B7:  MOVWF  07
05B8:  BCF    03.5
05B9:  BCF    07.1
....................    spi_write(0x33); 
05BA:  MOVF   13,W
05BB:  MOVLW  33
05BC:  MOVWF  13
05BD:  BSF    03.5
05BE:  BTFSS  14.0
05BF:  GOTO   5BE
....................    spi_write(0x0A); 
05C0:  BCF    03.5
05C1:  MOVF   13,W
05C2:  MOVLW  0A
05C3:  MOVWF  13
05C4:  BSF    03.5
05C5:  BTFSS  14.0
05C6:  GOTO   5C5
....................    output_high(RF_CS); 
05C7:  BCF    03.5
05C8:  BCF    37.1
05C9:  MOVF   37,W
05CA:  BSF    03.5
05CB:  MOVWF  07
05CC:  BCF    03.5
05CD:  BSF    07.1
.................... } 
05CE:  BCF    0A.3
05CF:  BSF    0A.4
05D0:  GOTO   043 (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                    RF_ON()                         * 
.................... //***************************************************** 
.................... //*Descripción:Esta rutina activa el módulo de        * 
.................... //*radiofrecuencia en modo escucha para poder recibir * 
.................... //*datos enviados a su dirección.                     * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_ON() 
.................... { 
....................  
....................    output_low(RF_CE); 
*
05E6:  BCF    37.2
05E7:  MOVF   37,W
05E8:  BSF    03.5
05E9:  MOVWF  07
05EA:  BCF    03.5
05EB:  BCF    07.2
....................  
....................    // CONFIG 
....................    //Se activa el modulo, se pone en recepción, 
....................    //se activa el CRC para que utilice 2 bytes. 
....................    output_low(RF_CS); 
05EC:  BCF    37.1
05ED:  MOVF   37,W
05EE:  BSF    03.5
05EF:  MOVWF  07
05F0:  BCF    03.5
05F1:  BCF    07.1
....................    spi_write(0x20); 
05F2:  MOVF   13,W
05F3:  MOVLW  20
05F4:  MOVWF  13
05F5:  BSF    03.5
05F6:  BTFSS  14.0
05F7:  GOTO   5F6
....................    spi_write(0x0F); 
05F8:  BCF    03.5
05F9:  MOVF   13,W
05FA:  MOVLW  0F
05FB:  MOVWF  13
05FC:  BSF    03.5
05FD:  BTFSS  14.0
05FE:  GOTO   5FD
....................    output_high(RF_CS); 
05FF:  BCF    03.5
0600:  BCF    37.1
0601:  MOVF   37,W
0602:  BSF    03.5
0603:  MOVWF  07
0604:  BCF    03.5
0605:  BSF    07.1
....................  
....................    delay_ms(2); 
0606:  MOVLW  02
0607:  MOVWF  68
0608:  CALL   5D1
....................    output_high(RF_CE); 
0609:  BCF    37.2
060A:  MOVF   37,W
060B:  BSF    03.5
060C:  MOVWF  07
060D:  BCF    03.5
060E:  BSF    07.2
....................    delay_us(150); 
060F:  MOVLW  31
0610:  MOVWF  77
0611:  DECFSZ 77,F
0612:  GOTO   611
0613:  GOTO   614
.................... } 
0614:  BCF    0A.3
0615:  BSF    0A.4
0616:  GOTO   046 (RETURN)
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_OFF()                         * 
.................... //***************************************************** 
.................... //*Descripción:Este procedimiento desactiva el módulo * 
.................... //*de radiofrecuencia.                                * 
.................... //***************************************************** 
.................... //*Variables de entrada:                              * 
.................... //*Variables de salida:                               * 
.................... //***************************************************** 
.................... void RF_OFF() 
.................... { 
....................    output_low(RF_CE); 
....................  
....................    // CONFIG 
....................    //Se desactiva el modulo 
....................    output_low(RF_CS); 
....................    spi_write(0x20); 
....................    spi_write(0x0C); 
....................    output_high(RF_CS); 
.................... } 
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_SEND()                         * 
.................... //***************************************************** 
.................... //*Descripción:Esta función envía 8 Bytes de datos a  * 
.................... //*la dirección indicada informando de la correcta    * 
.................... //*recepción en el destinatario.                      * 
.................... //***************************************************** 
.................... //*Variables de entrada:- RF_DATA[]                   * 
.................... //*                     - RF_DIR 
.................... //*Variables de salida: -                             * 
.................... //*Salida:              - 0: Envío correcto (ACK OK)  * 
.................... //*                     - 1: No recepcibido (NO ACK)  * 
.................... //*                     - 2: No enviado               * 
.................... //***************************************************** 
.................... int RF_SEND() 
.................... { 
....................    int i; 
....................    int estado; 
....................  
....................  
....................    if(bit_test(INTCON,7)) 
*
0800:  BTFSS  0B.7
0801:  GOTO   004
....................       interRF=1; 
0802:  BSF    29.0
....................    else 
0803:  GOTO   005
....................       interRF=0; 
0804:  BCF    29.0
....................  
....................    disable_interrupts(GLOBAL); 
0805:  BCF    0B.6
0806:  BCF    0B.7
0807:  BTFSC  0B.7
0808:  GOTO   006
....................  
....................    // INICIO 
....................    output_low(RF_CE); 
0809:  BCF    37.2
080A:  MOVF   37,W
080B:  BSF    03.5
080C:  MOVWF  07
080D:  BCF    03.5
080E:  BCF    07.2
....................  
....................    //STATUS 
....................    //Reseteo del registro STATUS 
....................    output_low(RF_CS); 
080F:  BCF    37.1
0810:  MOVF   37,W
0811:  BSF    03.5
0812:  MOVWF  07
0813:  BCF    03.5
0814:  BCF    07.1
....................    spi_write(0x27); 
0815:  MOVF   13,W
0816:  MOVLW  27
0817:  MOVWF  13
0818:  BSF    03.5
0819:  BTFSS  14.0
081A:  GOTO   019
....................    spi_write(0x70); 
081B:  BCF    03.5
081C:  MOVF   13,W
081D:  MOVLW  70
081E:  MOVWF  13
081F:  BSF    03.5
0820:  BTFSS  14.0
0821:  GOTO   020
....................    output_high(RF_CS); 
0822:  BCF    03.5
0823:  BCF    37.1
0824:  MOVF   37,W
0825:  BSF    03.5
0826:  MOVWF  07
0827:  BCF    03.5
0828:  BSF    07.1
....................  
....................    // EN_RXADDR 
....................    //Se habilita el Pipe0 para la recepción del ACK 
....................    output_low(RF_CS); 
0829:  BCF    37.1
082A:  MOVF   37,W
082B:  BSF    03.5
082C:  MOVWF  07
082D:  BCF    03.5
082E:  BCF    07.1
....................    spi_write(0x22); 
082F:  MOVF   13,W
0830:  MOVLW  22
0831:  MOVWF  13
0832:  BSF    03.5
0833:  BTFSS  14.0
0834:  GOTO   033
....................    spi_write(0x01); 
0835:  BCF    03.5
0836:  MOVF   13,W
0837:  MOVLW  01
0838:  MOVWF  13
0839:  BSF    03.5
083A:  BTFSS  14.0
083B:  GOTO   03A
....................    output_high(RF_CS); 
083C:  BCF    03.5
083D:  BCF    37.1
083E:  MOVF   37,W
083F:  BSF    03.5
0840:  MOVWF  07
0841:  BCF    03.5
0842:  BSF    07.1
....................  
....................    // TX_ADDR 
....................    //Se configura la dirección de transmisión=RF_DIR 
....................    output_low(RF_CS); 
0843:  BCF    37.1
0844:  MOVF   37,W
0845:  BSF    03.5
0846:  MOVWF  07
0847:  BCF    03.5
0848:  BCF    07.1
....................    spi_write(0x30); 
0849:  MOVF   13,W
084A:  MOVLW  30
084B:  MOVWF  13
084C:  BSF    03.5
084D:  BTFSS  14.0
084E:  GOTO   04D
....................    spi_write(RF_DIR); 
084F:  BCF    03.5
0850:  MOVF   36,W
0851:  MOVWF  13
0852:  BSF    03.5
0853:  BTFSS  14.0
0854:  GOTO   053
....................    spi_write(0xC2); 
0855:  BCF    03.5
0856:  MOVF   13,W
0857:  MOVLW  C2
0858:  MOVWF  13
0859:  BSF    03.5
085A:  BTFSS  14.0
085B:  GOTO   05A
....................    spi_write(0xC2); 
085C:  BCF    03.5
085D:  MOVF   13,W
085E:  MOVLW  C2
085F:  MOVWF  13
0860:  BSF    03.5
0861:  BTFSS  14.0
0862:  GOTO   061
....................    spi_write(0xC2); 
0863:  BCF    03.5
0864:  MOVF   13,W
0865:  MOVLW  C2
0866:  MOVWF  13
0867:  BSF    03.5
0868:  BTFSS  14.0
0869:  GOTO   068
....................    spi_write(0xC2); 
086A:  BCF    03.5
086B:  MOVF   13,W
086C:  MOVLW  C2
086D:  MOVWF  13
086E:  BSF    03.5
086F:  BTFSS  14.0
0870:  GOTO   06F
....................    output_high(RF_CS); 
0871:  BCF    03.5
0872:  BCF    37.1
0873:  MOVF   37,W
0874:  BSF    03.5
0875:  MOVWF  07
0876:  BCF    03.5
0877:  BSF    07.1
....................  
....................    // RX_ADDR_P0 
....................    //Para la recepción del ACK se debe configurar el Pipe0 con 
....................    //la misma dirección a trasmitir. 
....................    output_low(RF_CS); 
0878:  BCF    37.1
0879:  MOVF   37,W
087A:  BSF    03.5
087B:  MOVWF  07
087C:  BCF    03.5
087D:  BCF    07.1
....................    spi_write(0x2A); 
087E:  MOVF   13,W
087F:  MOVLW  2A
0880:  MOVWF  13
0881:  BSF    03.5
0882:  BTFSS  14.0
0883:  GOTO   082
....................    spi_write(RF_DIR); 
0884:  BCF    03.5
0885:  MOVF   36,W
0886:  MOVWF  13
0887:  BSF    03.5
0888:  BTFSS  14.0
0889:  GOTO   088
....................    spi_write(0xC2); 
088A:  BCF    03.5
088B:  MOVF   13,W
088C:  MOVLW  C2
088D:  MOVWF  13
088E:  BSF    03.5
088F:  BTFSS  14.0
0890:  GOTO   08F
....................    spi_write(0xC2); 
0891:  BCF    03.5
0892:  MOVF   13,W
0893:  MOVLW  C2
0894:  MOVWF  13
0895:  BSF    03.5
0896:  BTFSS  14.0
0897:  GOTO   096
....................    spi_write(0xC2); 
0898:  BCF    03.5
0899:  MOVF   13,W
089A:  MOVLW  C2
089B:  MOVWF  13
089C:  BSF    03.5
089D:  BTFSS  14.0
089E:  GOTO   09D
....................    spi_write(0xC2); 
089F:  BCF    03.5
08A0:  MOVF   13,W
08A1:  MOVLW  C2
08A2:  MOVWF  13
08A3:  BSF    03.5
08A4:  BTFSS  14.0
08A5:  GOTO   0A4
....................    output_high(RF_CS); 
08A6:  BCF    03.5
08A7:  BCF    37.1
08A8:  MOVF   37,W
08A9:  BSF    03.5
08AA:  MOVWF  07
08AB:  BCF    03.5
08AC:  BSF    07.1
....................  
....................    // RX_ADDR_P1 
....................    //Se mete en RF_DIR la direccion propia. 
....................    //De esta manera el receptor sabe la dirección 
....................    //del transmisor. 
....................    output_low(RF_CS); 
08AD:  BCF    37.1
08AE:  MOVF   37,W
08AF:  BSF    03.5
08B0:  MOVWF  07
08B1:  BCF    03.5
08B2:  BCF    07.1
....................    spi_write(0x0B); 
08B3:  MOVF   13,W
08B4:  MOVLW  0B
08B5:  MOVWF  13
08B6:  BSF    03.5
08B7:  BTFSS  14.0
08B8:  GOTO   0B7
....................    RF_DIR=spi_read(0); 
08B9:  BCF    03.5
08BA:  MOVF   13,W
08BB:  CLRF   13
08BC:  BSF    03.5
08BD:  BTFSS  14.0
08BE:  GOTO   0BD
08BF:  BCF    03.5
08C0:  MOVF   13,W
08C1:  MOVWF  36
....................    spi_read(0); 
08C2:  MOVF   13,W
08C3:  CLRF   13
08C4:  BSF    03.5
08C5:  BTFSS  14.0
08C6:  GOTO   0C5
....................    spi_read(0); 
08C7:  BCF    03.5
08C8:  MOVF   13,W
08C9:  CLRF   13
08CA:  BSF    03.5
08CB:  BTFSS  14.0
08CC:  GOTO   0CB
....................    spi_read(0); 
08CD:  BCF    03.5
08CE:  MOVF   13,W
08CF:  CLRF   13
08D0:  BSF    03.5
08D1:  BTFSS  14.0
08D2:  GOTO   0D1
....................    spi_read(0); 
08D3:  BCF    03.5
08D4:  MOVF   13,W
08D5:  CLRF   13
08D6:  BSF    03.5
08D7:  BTFSS  14.0
08D8:  GOTO   0D7
....................    output_high(RF_CS); 
08D9:  BCF    03.5
08DA:  BCF    37.1
08DB:  MOVF   37,W
08DC:  BSF    03.5
08DD:  MOVWF  07
08DE:  BCF    03.5
08DF:  BSF    07.1
....................  
....................    // W_TX_PAYLOAD 
....................    //Se manda los datos al transductor 
....................    output_low(RF_CS); 
08E0:  BCF    37.1
08E1:  MOVF   37,W
08E2:  BSF    03.5
08E3:  MOVWF  07
08E4:  BCF    03.5
08E5:  BCF    07.1
....................    spi_write(0xA0); 
08E6:  MOVF   13,W
08E7:  MOVLW  A0
08E8:  MOVWF  13
08E9:  BSF    03.5
08EA:  BTFSS  14.0
08EB:  GOTO   0EA
....................  
....................    DATA_N_SND++; 
08EC:  BCF    03.5
08ED:  INCF   2C,F
....................    spi_write(DATA_N_SND); 
08EE:  MOVF   2C,W
08EF:  MOVWF  13
08F0:  BSF    03.5
08F1:  BTFSS  14.0
08F2:  GOTO   0F1
....................    spi_write(RF_DIR); 
08F3:  BCF    03.5
08F4:  MOVF   36,W
08F5:  MOVWF  13
08F6:  BSF    03.5
08F7:  BTFSS  14.0
08F8:  GOTO   0F7
....................    for (i=0;i<8;i++) 
08F9:  BCF    03.5
08FA:  CLRF   67
08FB:  MOVF   67,W
08FC:  SUBLW  07
08FD:  BTFSS  03.0
08FE:  GOTO   10D
....................       spi_write(RF_DATA[i]); 
08FF:  MOVLW  2E
0900:  ADDWF  67,W
0901:  MOVWF  04
0902:  BCF    03.7
0903:  MOVF   00,W
0904:  MOVWF  69
0905:  MOVF   69,W
0906:  MOVWF  13
0907:  BSF    03.5
0908:  BTFSS  14.0
0909:  GOTO   108
090A:  BCF    03.5
090B:  INCF   67,F
090C:  GOTO   0FB
....................  
....................    output_high(RF_CS); 
090D:  BCF    37.1
090E:  MOVF   37,W
090F:  BSF    03.5
0910:  MOVWF  07
0911:  BCF    03.5
0912:  BSF    07.1
....................  
....................    // CONFIG 
....................    //Se pasa a modo transmisión. 
....................    output_low(RF_CS); 
0913:  BCF    37.1
0914:  MOVF   37,W
0915:  BSF    03.5
0916:  MOVWF  07
0917:  BCF    03.5
0918:  BCF    07.1
....................    spi_write(0x20); 
0919:  MOVF   13,W
091A:  MOVLW  20
091B:  MOVWF  13
091C:  BSF    03.5
091D:  BTFSS  14.0
091E:  GOTO   11D
....................    spi_write(0x0E); 
091F:  BCF    03.5
0920:  MOVF   13,W
0921:  MOVLW  0E
0922:  MOVWF  13
0923:  BSF    03.5
0924:  BTFSS  14.0
0925:  GOTO   124
....................    output_high(RF_CS); 
0926:  BCF    03.5
0927:  BCF    37.1
0928:  MOVF   37,W
0929:  BSF    03.5
092A:  MOVWF  07
092B:  BCF    03.5
092C:  BSF    07.1
....................  
....................    // Pulso de comienzo de envío 
....................    output_high(RF_CE); 
092D:  BCF    37.2
092E:  MOVF   37,W
092F:  BSF    03.5
0930:  MOVWF  07
0931:  BCF    03.5
0932:  BSF    07.2
....................    delay_us(15); 
0933:  MOVLW  04
0934:  MOVWF  77
0935:  DECFSZ 77,F
0936:  GOTO   135
0937:  GOTO   138
....................    output_low(RF_CE); 
0938:  BCF    37.2
0939:  MOVF   37,W
093A:  BSF    03.5
093B:  MOVWF  07
093C:  BCF    03.5
093D:  BCF    07.2
....................  
....................    noRF=0; 
093E:  CLRF   2B
093F:  CLRF   2A
....................  
....................    while (input(RF_IRQ)==1) { 
0940:  BSF    03.5
0941:  BSF    06.0
0942:  BCF    03.5
0943:  BTFSS  06.0
0944:  GOTO   150
....................       noRF++; 
0945:  INCF   2A,F
0946:  BTFSC  03.2
0947:  INCF   2B,F
....................       //Si no da respuesta en 7ms, no se ha enviado. 
....................       if(noRF==500){ 
0948:  MOVF   2A,W
0949:  SUBLW  F4
094A:  BTFSS  03.2
094B:  GOTO   14F
094C:  DECFSZ 2B,W
094D:  GOTO   14F
....................       break; 
094E:  GOTO   150
....................          } 
....................    } 
094F:  GOTO   140
....................  
....................  
....................    // STATUS 
....................    //Lectura del estado en el registro estatus. 
....................    output_low(RF_CS); 
0950:  BCF    37.1
0951:  MOVF   37,W
0952:  BSF    03.5
0953:  MOVWF  07
0954:  BCF    03.5
0955:  BCF    07.1
....................    estado=spi_read(0x27); 
0956:  MOVF   13,W
0957:  MOVLW  27
0958:  MOVWF  13
0959:  BSF    03.5
095A:  BTFSS  14.0
095B:  GOTO   15A
095C:  BCF    03.5
095D:  MOVF   13,W
095E:  MOVWF  68
....................    spi_write(0x70); 
095F:  MOVF   13,W
0960:  MOVLW  70
0961:  MOVWF  13
0962:  BSF    03.5
0963:  BTFSS  14.0
0964:  GOTO   163
....................    output_high(RF_CS); 
0965:  BCF    03.5
0966:  BCF    37.1
0967:  MOVF   37,W
0968:  BSF    03.5
0969:  MOVWF  07
096A:  BCF    03.5
096B:  BSF    07.1
....................  
....................  
....................    // EN_RXADDR 
....................    //Habilitar los Pipe0,Pipe1 y Pipe2. 
....................    output_low(RF_CS); 
096C:  BCF    37.1
096D:  MOVF   37,W
096E:  BSF    03.5
096F:  MOVWF  07
0970:  BCF    03.5
0971:  BCF    07.1
....................    spi_write(0x22); 
0972:  MOVF   13,W
0973:  MOVLW  22
0974:  MOVWF  13
0975:  BSF    03.5
0976:  BTFSS  14.0
0977:  GOTO   176
....................    spi_write(0x07); 
0978:  BCF    03.5
0979:  MOVF   13,W
097A:  MOVLW  07
097B:  MOVWF  13
097C:  BSF    03.5
097D:  BTFSS  14.0
097E:  GOTO   17D
....................    output_high(RF_CS); 
097F:  BCF    03.5
0980:  BCF    37.1
0981:  MOVF   37,W
0982:  BSF    03.5
0983:  MOVWF  07
0984:  BCF    03.5
0985:  BSF    07.1
....................  
....................       // TX_FLUSH 
....................    //Limpieza de la FIFO de salida 
....................    output_low(RF_CS); 
0986:  BCF    37.1
0987:  MOVF   37,W
0988:  BSF    03.5
0989:  MOVWF  07
098A:  BCF    03.5
098B:  BCF    07.1
....................    spi_write(0xE1); 
098C:  MOVF   13,W
098D:  MOVLW  E1
098E:  MOVWF  13
098F:  BSF    03.5
0990:  BTFSS  14.0
0991:  GOTO   190
....................    output_high(RF_CS); 
0992:  BCF    03.5
0993:  BCF    37.1
0994:  MOVF   37,W
0995:  BSF    03.5
0996:  MOVWF  07
0997:  BCF    03.5
0998:  BSF    07.1
....................  
....................    // CONFIG 
....................    //Paso a modo recepción 
....................    output_low(RF_CS); 
0999:  BCF    37.1
099A:  MOVF   37,W
099B:  BSF    03.5
099C:  MOVWF  07
099D:  BCF    03.5
099E:  BCF    07.1
....................    spi_write(0x20); 
099F:  MOVF   13,W
09A0:  MOVLW  20
09A1:  MOVWF  13
09A2:  BSF    03.5
09A3:  BTFSS  14.0
09A4:  GOTO   1A3
....................    spi_write(0x0F); 
09A5:  BCF    03.5
09A6:  MOVF   13,W
09A7:  MOVLW  0F
09A8:  MOVWF  13
09A9:  BSF    03.5
09AA:  BTFSS  14.0
09AB:  GOTO   1AA
....................    output_high(RF_CS); 
09AC:  BCF    03.5
09AD:  BCF    37.1
09AE:  MOVF   37,W
09AF:  BSF    03.5
09B0:  MOVWF  07
09B1:  BCF    03.5
09B2:  BSF    07.1
....................  
....................    // FIN 
....................    output_high(RF_CE); 
09B3:  BCF    37.2
09B4:  MOVF   37,W
09B5:  BSF    03.5
09B6:  MOVWF  07
09B7:  BCF    03.5
09B8:  BSF    07.2
....................  
....................    delay_us(150); 
09B9:  MOVLW  31
09BA:  MOVWF  77
09BB:  DECFSZ 77,F
09BC:  GOTO   1BB
09BD:  GOTO   1BE
....................  
....................    //Si no da respuesta en 7ms, no se ha enviado. 
....................    if(noRF==500){ 
09BE:  MOVF   2A,W
09BF:  SUBLW  F4
09C0:  BTFSS  03.2
09C1:  GOTO   1CC
09C2:  DECFSZ 2B,W
09C3:  GOTO   1CC
....................         if(interRF==1) 
09C4:  BTFSS  29.0
09C5:  GOTO   1C8
....................         enable_interrupts(GLOBAL); 
09C6:  MOVLW  C0
09C7:  IORWF  0B,F
....................         clear_interrupt(int_ext); 
09C8:  BCF    0B.1
....................         return(2); 
09C9:  MOVLW  02
09CA:  MOVWF  78
09CB:  GOTO   1E1
....................    } 
....................  
....................    //estado 
....................    //Chequeo de los bit del registro STATUS que indican si se ha recibido 
....................    //ACK y si se ha terminado las retrasmisiones sin ningun ACK. 
....................    if ((bit_test(estado,4)==0) && (bit_test(estado,5)==1)){ 
09CC:  BTFSC  68.4
09CD:  GOTO   1D9
09CE:  BTFSS  68.5
09CF:  GOTO   1D9
....................       if(interRF==1) 
09D0:  BTFSS  29.0
09D1:  GOTO   1D4
....................       enable_interrupts(GLOBAL); 
09D2:  MOVLW  C0
09D3:  IORWF  0B,F
....................       clear_interrupt(int_ext); 
09D4:  BCF    0B.1
....................       return(0); 
09D5:  MOVLW  00
09D6:  MOVWF  78
09D7:  GOTO   1E1
....................       } 
....................    else{ 
09D8:  GOTO   1E1
....................       if(interRF==1) 
09D9:  BTFSS  29.0
09DA:  GOTO   1DD
....................       enable_interrupts(GLOBAL); 
09DB:  MOVLW  C0
09DC:  IORWF  0B,F
....................       clear_interrupt(int_ext); 
09DD:  BCF    0B.1
....................       return(1); 
09DE:  MOVLW  01
09DF:  MOVWF  78
09E0:  GOTO   1E1
....................       } 
.................... } 
09E1:  RETLW  00
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************** 
.................... //*                 RF_RECEIVE()                      * 
.................... //***************************************************** 
.................... //*Descripción: Esta rutina se encarga de comprobar si* 
.................... //*se ha producido una recepción y de ser así,        * 
.................... //*devuelve la trama recibida.                        * 
.................... //***************************************************** 
.................... //*Variables de entrada:-                             * 
.................... //*Variables de salida: - RF_DATA[]                   * 
.................... //*                     - RF_DIR                      * 
.................... //*Salida:         - 0: Recepción correcta y única    * 
.................... //*                - 1: Recepción correcta y múltiple * 
.................... //*                - 2: No se ha producido recepción  * 
.................... //*                - 3: No se ha producido recepción  * 
.................... //***************************************************** 
.................... int RF_RECEIVE() 
.................... { 
....................  
....................    int i; 
....................    int mas; 
....................    int estado; 
....................  
....................    if (input(RF_IRQ)==1 && RCVNW==0){ 
*
02E6:  BSF    03.5
02E7:  BSF    06.0
02E8:  BCF    03.5
02E9:  BTFSS  06.0
02EA:  GOTO   2F0
02EB:  BTFSC  29.1
02EC:  GOTO   2F0
....................       return (2); 
02ED:  MOVLW  02
02EE:  MOVWF  78
02EF:  GOTO   37F
....................       } 
....................  
....................    //STATUS 
....................    //Lectura y reseteo del registro STATUS 
....................    output_low(RF_CS); 
02F0:  BCF    37.1
02F1:  MOVF   37,W
02F2:  BSF    03.5
02F3:  MOVWF  07
02F4:  BCF    03.5
02F5:  BCF    07.1
....................    estado=spi_read(0x27); 
02F6:  MOVF   13,W
02F7:  MOVLW  27
02F8:  MOVWF  13
02F9:  BSF    03.5
02FA:  BTFSS  14.0
02FB:  GOTO   2FA
02FC:  BCF    03.5
02FD:  MOVF   13,W
02FE:  BSF    03.5
02FF:  MOVWF  3C
....................    spi_write(0x70); 
0300:  BCF    03.5
0301:  MOVF   13,W
0302:  MOVLW  70
0303:  MOVWF  13
0304:  BSF    03.5
0305:  BTFSS  14.0
0306:  GOTO   305
....................    output_high(RF_CS); 
0307:  BCF    03.5
0308:  BCF    37.1
0309:  MOVF   37,W
030A:  BSF    03.5
030B:  MOVWF  07
030C:  BCF    03.5
030D:  BSF    07.1
....................  
....................    //estado 
....................    //Chequeo de la interrupción de recepción. 
....................    if (bit_test(estado,6)==0 && RCVNW==0){ 
030E:  BSF    03.5
030F:  BTFSC  3C.6
0310:  GOTO   31A
0311:  BCF    03.5
0312:  BTFSS  29.1
0313:  GOTO   316
0314:  BSF    03.5
0315:  GOTO   31A
....................       return(3); 
0316:  MOVLW  03
0317:  MOVWF  78
0318:  GOTO   37F
0319:  BSF    03.5
....................       } 
....................  
....................    //R_RX_PAYLOAD 
....................    //Lectura de los datos recibidos. 
....................    output_low(RF_CS); 
031A:  BCF    03.5
031B:  BCF    37.1
031C:  MOVF   37,W
031D:  BSF    03.5
031E:  MOVWF  07
031F:  BCF    03.5
0320:  BCF    07.1
....................    spi_write(0x61); 
0321:  MOVF   13,W
0322:  MOVLW  61
0323:  MOVWF  13
0324:  BSF    03.5
0325:  BTFSS  14.0
0326:  GOTO   325
....................    DATA_N_RCV=spi_read(0); 
0327:  BCF    03.5
0328:  MOVF   13,W
0329:  CLRF   13
032A:  BSF    03.5
032B:  BTFSS  14.0
032C:  GOTO   32B
032D:  BCF    03.5
032E:  MOVF   13,W
032F:  MOVWF  2D
....................    RF_DIR=spi_read(0); 
0330:  MOVF   13,W
0331:  CLRF   13
0332:  BSF    03.5
0333:  BTFSS  14.0
0334:  GOTO   333
0335:  BCF    03.5
0336:  MOVF   13,W
0337:  MOVWF  36
....................    for (i=0;i<8;i++) 
0338:  BSF    03.5
0339:  CLRF   3A
033A:  MOVF   3A,W
033B:  SUBLW  07
033C:  BTFSS  03.0
033D:  GOTO   34E
....................    { 
....................       RF_DATA[i]=spi_read(0); 
033E:  MOVLW  2E
033F:  ADDWF  3A,W
0340:  MOVWF  04
0341:  BCF    03.7
0342:  BCF    03.5
0343:  MOVF   13,W
0344:  CLRF   13
0345:  BSF    03.5
0346:  BTFSS  14.0
0347:  GOTO   346
0348:  BCF    03.5
0349:  MOVF   13,W
034A:  MOVWF  00
....................    } 
034B:  BSF    03.5
034C:  INCF   3A,F
034D:  GOTO   33A
....................    output_high(RF_CS); 
034E:  BCF    03.5
034F:  BCF    37.1
0350:  MOVF   37,W
0351:  BSF    03.5
0352:  MOVWF  07
0353:  BCF    03.5
0354:  BSF    07.1
....................  
....................    //FIFO_STATUS 
....................    //Comprobación del estado de la FIFO de 
....................    //recepción para comprobar si hay más datos 
....................    output_low(RF_CS); 
0355:  BCF    37.1
0356:  MOVF   37,W
0357:  BSF    03.5
0358:  MOVWF  07
0359:  BCF    03.5
035A:  BCF    07.1
....................    spi_write(0x17); 
035B:  MOVF   13,W
035C:  MOVLW  17
035D:  MOVWF  13
035E:  BSF    03.5
035F:  BTFSS  14.0
0360:  GOTO   35F
....................    mas=spi_read(0); 
0361:  BCF    03.5
0362:  MOVF   13,W
0363:  CLRF   13
0364:  BSF    03.5
0365:  BTFSS  14.0
0366:  GOTO   365
0367:  BCF    03.5
0368:  MOVF   13,W
0369:  BSF    03.5
036A:  MOVWF  3B
....................    output_high(RF_CS); 
036B:  BCF    03.5
036C:  BCF    37.1
036D:  MOVF   37,W
036E:  BSF    03.5
036F:  MOVWF  07
0370:  BCF    03.5
0371:  BSF    07.1
....................  
....................    if (bit_test(mas,0)==0){ 
0372:  BSF    03.5
0373:  BTFSC  3B.0
0374:  GOTO   37B
....................       RCVNW=1; 
0375:  BCF    03.5
0376:  BSF    29.1
....................       return(1); 
0377:  MOVLW  01
0378:  MOVWF  78
0379:  GOTO   37F
037A:  BSF    03.5
....................    } 
....................       RCVNW=0; 
037B:  BCF    03.5
037C:  BCF    29.1
....................       return(0); 
037D:  MOVLW  00
037E:  MOVWF  78
.................... } 
037F:  RETLW  00
.................... //***************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#include<stdio.h> 
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1025:  CLRF   38
1026:  CLRF   39
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #byte porta=0x05           // Dirección del puerto A. 
.................... //int8 valor; 
.................... int8 Dato1 = 0; 
1027:  CLRF   3A
.................... float Bat_lvl = 0.00;  
1028:  CLRF   3B
1029:  CLRF   3C
102A:  CLRF   3D
102B:  CLRF   3E
.................... char opcion; 
.................... int8 buffer[8]; 
.................... int8 Buff[24]; //Buffer para el frame. 
.................... int8 ret2; 
.................... float temperatura = 0.0; 
102C:  CLRF   61
102D:  CLRF   62
102E:  CLRF   63
102F:  CLRF   64
.................... int8 count = 0; 
1030:  CLRF   65
.................... int8 b = 0; 
1031:  CLRF   66
....................  
.................... // Funciones. 
....................  
.................... void procesar(){ 
....................     //int fc; 
....................     int i; 
....................      
....................      for (i=0;i<8;i++){ 
*
039E:  CLRF   3A
039F:  MOVF   3A,W
03A0:  SUBLW  07
03A1:  BTFSS  03.0
03A2:  GOTO   3B0
....................          printf("%c", RF_DATA[i]);         
03A3:  MOVLW  2E
03A4:  ADDWF  3A,W
03A5:  MOVWF  04
03A6:  BCF    03.7
03A7:  MOVF   00,W
03A8:  MOVWF  3B
03A9:  BCF    03.5
03AA:  BTFSS  0C.4
03AB:  GOTO   3AA
03AC:  MOVWF  19
....................     } 
03AD:  BSF    03.5
03AE:  INCF   3A,F
03AF:  GOTO   39F
....................     //printf(":"); 
....................     // Al tercer paquete, cambio de linea. 
....................     b++; 
03B0:  BCF    03.5
03B1:  INCF   66,F
....................     if (b==3){ 
03B2:  MOVF   66,W
03B3:  SUBLW  03
03B4:  BTFSS  03.2
03B5:  GOTO   3C9
....................     printf(" \r\n "); 
03B6:  BSF    03.5
03B7:  CLRF   3B
03B8:  MOVF   3B,W
03B9:  BCF    03.5
03BA:  CALL   033
03BB:  BSF    03.5
03BC:  INCF   3B,F
03BD:  MOVWF  77
03BE:  BCF    03.5
03BF:  BTFSS  0C.4
03C0:  GOTO   3BF
03C1:  MOVWF  19
03C2:  MOVLW  04
03C3:  BSF    03.5
03C4:  SUBWF  3B,W
03C5:  BTFSS  03.2
03C6:  GOTO   3B8
....................     b=0; 
03C7:  BCF    03.5
03C8:  CLRF   66
....................     } 
....................     /* 
....................     printf(" \r\n "); 
....................     printf("variableH: %U", RF_DATA[6]); 
....................     printf(" \r\n "); 
....................     printf("variableL: %U ", RF_DATA[7]); 
....................     printf(" \r\n "); 
....................     */ 
.................... } 
....................  
....................  
.................... #int_ext                   // Interrupción del módulo RF. 
.................... void int_RB0() 
.................... { 
....................     int8 ret1;    
....................     ret1 = RF_RECEIVE(); 
*
0380:  CALL   2E6
0381:  MOVF   78,W
0382:  BSF    03.5
0383:  MOVWF  39
....................       
....................    if ( (ret1 == 0) || (ret1 == 1) ) 
0384:  MOVF   39,F
0385:  BTFSC  03.2
0386:  GOTO   389
0387:  DECFSZ 39,W
0388:  GOTO   3D5
....................    { 
....................       do 
....................       {   
....................           buffer[0] = RF_DATA[0]; 
0389:  BCF    03.5
038A:  MOVF   2E,W
038B:  MOVWF  40
....................           buffer[1] = RF_DATA[1]; 
038C:  MOVF   2F,W
038D:  MOVWF  41
....................           buffer[2] = RF_DATA[2]; 
038E:  MOVF   30,W
038F:  MOVWF  42
....................           buffer[3] = RF_DATA[3]; 
0390:  MOVF   31,W
0391:  MOVWF  43
....................           buffer[4] = RF_DATA[4]; 
0392:  MOVF   32,W
0393:  MOVWF  44
....................           buffer[5] = RF_DATA[5]; 
0394:  MOVF   33,W
0395:  MOVWF  45
....................           buffer[6] = RF_DATA[6]; 
0396:  MOVF   34,W
0397:  MOVWF  46
....................           buffer[7] = RF_DATA[7]; 
0398:  MOVF   35,W
0399:  MOVWF  47
....................           ret1 = RF_RECEIVE();  
039A:  CALL   2E6
039B:  MOVF   78,W
039C:  BSF    03.5
039D:  MOVWF  39
....................           procesar();  //Procesamos cada paquete que se recibe. 
....................            
....................       }  
....................       while ( (ret1 == 0) || (ret1 == 1) );{ 
*
03C9:  BSF    03.5
03CA:  MOVF   39,F
03CB:  BTFSC  03.2
03CC:  GOTO   389
03CD:  DECFSZ 39,W
03CE:  GOTO   3D0
03CF:  GOTO   389
....................                ret1 = RF_RECEIVE();  
03D0:  BCF    03.5
03D1:  CALL   2E6
03D2:  MOVF   78,W
03D3:  BSF    03.5
03D4:  MOVWF  39
....................            
....................       } 
....................        
....................    } 
....................     
.................... } 
....................  
03D5:  BCF    03.5
03D6:  BCF    0B.1
03D7:  BCF    0A.3
03D8:  BCF    0A.4
03D9:  GOTO   01D
.................... void mote1(){ 
....................  
....................    printf("\r\n" ); 
*
0695:  MOVLW  0D
0696:  BTFSS  0C.4
0697:  GOTO   696
0698:  MOVWF  19
0699:  MOVLW  0A
069A:  BTFSS  0C.4
069B:  GOTO   69A
069C:  MOVWF  19
....................    printf("Estado Mote 1 \r\n" ); 
069D:  CLRF   67
069E:  MOVF   67,W
069F:  CALL   03C
06A0:  INCF   67,F
06A1:  MOVWF  77
06A2:  MOVF   77,W
06A3:  BTFSS  0C.4
06A4:  GOTO   6A3
06A5:  MOVWF  19
06A6:  MOVLW  10
06A7:  SUBWF  67,W
06A8:  BTFSS  03.2
06A9:  GOTO   69E
....................    printf("Conectando..." ); 
06AA:  CLRF   67
06AB:  MOVF   67,W
06AC:  CALL   051
06AD:  INCF   67,F
06AE:  MOVWF  77
06AF:  MOVF   77,W
06B0:  BTFSS  0C.4
06B1:  GOTO   6B0
06B2:  MOVWF  19
06B3:  MOVLW  0D
06B4:  SUBWF  67,W
06B5:  BTFSS  03.2
06B6:  GOTO   6AB
....................    //Envio un comando para solicitar informacion. 
....................    RF_DATA[0] = 100; 
06B7:  MOVLW  64
06B8:  MOVWF  2E
....................    RF_DATA[1] = 100; 
06B9:  MOVWF  2F
....................    RF_DATA[2] = 100; 
06BA:  MOVWF  30
....................    RF_DATA[3] = 100; 
06BB:  MOVWF  31
....................    RF_DIR=0x01;           // Dirección del receptor. 
06BC:  MOVLW  01
06BD:  MOVWF  36
....................    ret2=RF_SEND();        // Enviar datos. 
06BE:  BSF    0A.3
06BF:  CALL   000
06C0:  BCF    0A.3
06C1:  MOVF   78,W
06C2:  MOVWF  60
....................    delay_ms(3000);        //Tiempo de espera para recibir la respuesta. 
06C3:  MOVLW  0C
06C4:  MOVWF  67
06C5:  MOVLW  FA
06C6:  MOVWF  68
06C7:  CALL   5D1
06C8:  DECFSZ 67,F
06C9:  GOTO   6C5
....................    Dato1 = buffer[0]; 
06CA:  MOVF   40,W
06CB:  MOVWF  3A
....................    /* 
....................    Bat_lvl = (Dato1/256.0)*10.0; 
....................    temperatura = buffer[3]; 
....................    temperatura = (temperatura*(5.0/256.0)); 
....................    temperatura = temperatura - 0.5; 
....................    temperatura = temperatura/0.01; 
....................    */ 
....................    printf("OK \r\n" ); 
06CC:  CLRF   67
06CD:  MOVF   67,W
06CE:  CALL   063
06CF:  INCF   67,F
06D0:  MOVWF  77
06D1:  MOVF   77,W
06D2:  BTFSS  0C.4
06D3:  GOTO   6D2
06D4:  MOVWF  19
06D5:  MOVLW  05
06D6:  SUBWF  67,W
06D7:  BTFSS  03.2
06D8:  GOTO   6CD
....................    //printf("Nivel Bateria: %2.2f V \r\n", Bat_lvl); 
....................    printf("Dato recibido_[0]: %U ",buffer[0]); 
06D9:  CLRF   67
06DA:  MOVF   67,W
06DB:  CALL   06D
06DC:  INCF   67,F
06DD:  MOVWF  77
06DE:  MOVF   77,W
06DF:  BTFSS  0C.4
06E0:  GOTO   6DF
06E1:  MOVWF  19
06E2:  MOVLW  13
06E3:  SUBWF  67,W
06E4:  BTFSS  03.2
06E5:  GOTO   6DA
06E6:  MOVF   40,W
06E7:  MOVWF  68
06E8:  MOVLW  1B
06E9:  MOVWF  69
*
0720:  MOVLW  20
0721:  BTFSS  0C.4
0722:  GOTO   721
0723:  MOVWF  19
....................    printf("  Dato recibido_[1]: %D ",buffer[1]); 
0724:  CLRF   67
0725:  MOVF   67,W
0726:  CALL   088
0727:  INCF   67,F
0728:  MOVWF  77
0729:  MOVF   77,W
072A:  BTFSS  0C.4
072B:  GOTO   72A
072C:  MOVWF  19
072D:  MOVLW  15
072E:  SUBWF  67,W
072F:  BTFSS  03.2
0730:  GOTO   725
0731:  MOVF   41,W
0732:  MOVWF  6B
0733:  MOVLW  1F
0734:  MOVWF  6C
0735:  CALL   62C
0736:  MOVLW  20
0737:  BTFSS  0C.4
0738:  GOTO   737
0739:  MOVWF  19
....................    printf("  Dato recibido_[2]: %D \r\n",buffer[2]); 
073A:  CLRF   67
073B:  MOVF   67,W
073C:  CALL   0A5
073D:  INCF   67,F
073E:  MOVWF  77
073F:  MOVF   77,W
0740:  BTFSS  0C.4
0741:  GOTO   740
0742:  MOVWF  19
0743:  MOVLW  15
0744:  SUBWF  67,W
0745:  BTFSS  03.2
0746:  GOTO   73B
0747:  MOVF   42,W
0748:  MOVWF  6B
0749:  MOVLW  1F
074A:  MOVWF  6C
074B:  CALL   62C
074C:  MOVLW  20
074D:  BTFSS  0C.4
074E:  GOTO   74D
074F:  MOVWF  19
0750:  MOVLW  0D
0751:  BTFSS  0C.4
0752:  GOTO   751
0753:  MOVWF  19
0754:  MOVLW  0A
0755:  BTFSS  0C.4
0756:  GOTO   755
0757:  MOVWF  19
....................    printf("Dato recibido_[3]: %D \r\n ",buffer[3]); 
0758:  CLRF   67
0759:  MOVF   67,W
075A:  CALL   0C4
075B:  INCF   67,F
075C:  MOVWF  77
075D:  MOVF   77,W
075E:  BTFSS  0C.4
075F:  GOTO   75E
0760:  MOVWF  19
0761:  MOVLW  13
0762:  SUBWF  67,W
0763:  BTFSS  03.2
0764:  GOTO   759
0765:  MOVF   43,W
0766:  MOVWF  6B
0767:  MOVLW  1F
0768:  MOVWF  6C
0769:  CALL   62C
076A:  MOVLW  15
076B:  MOVWF  68
076C:  MOVF   68,W
076D:  CALL   0C4
076E:  INCF   68,F
076F:  MOVWF  77
0770:  MOVF   77,W
0771:  BTFSS  0C.4
0772:  GOTO   771
0773:  MOVWF  19
0774:  MOVLW  19
0775:  SUBWF  68,W
0776:  BTFSS  03.2
0777:  GOTO   76C
....................    printf(" \r\n "); 
0778:  CLRF   67
0779:  MOVF   67,W
077A:  CALL   033
077B:  INCF   67,F
077C:  MOVWF  77
077D:  MOVF   77,W
077E:  BTFSS  0C.4
077F:  GOTO   77E
0780:  MOVWF  19
0781:  MOVLW  04
0782:  SUBWF  67,W
0783:  BTFSS  03.2
0784:  GOTO   779
....................   // printf("Temperatura_[3]: %2.2f \r\n ",temperatura); 
.................... } 
0785:  RETLW  00
....................  
....................  
....................  
.................... void modo_2(){ 
....................    printf("---- Pulsado 2---- \r\n"); 
*
0C6E:  CLRF   67
0C6F:  MOVF   67,W
0C70:  BCF    0A.3
0C71:  CALL   0E2
0C72:  BSF    0A.3
0C73:  INCF   67,F
0C74:  MOVWF  77
0C75:  MOVF   77,W
0C76:  BTFSS  0C.4
0C77:  GOTO   476
0C78:  MOVWF  19
0C79:  MOVLW  15
0C7A:  SUBWF  67,W
0C7B:  BTFSS  03.2
0C7C:  GOTO   46F
....................    printf("---- Modo grabar datos---- \r\n"); 
0C7D:  CLRF   67
0C7E:  MOVF   67,W
0C7F:  BCF    0A.3
0C80:  CALL   0FC
0C81:  BSF    0A.3
0C82:  INCF   67,F
0C83:  MOVWF  77
0C84:  MOVF   77,W
0C85:  BTFSS  0C.4
0C86:  GOTO   485
0C87:  MOVWF  19
0C88:  MOVLW  1D
0C89:  SUBWF  67,W
0C8A:  BTFSS  03.2
0C8B:  GOTO   47E
....................    while(1) 
....................    { 
....................    RF_DATA[0] = 100; 
0C8C:  MOVLW  64
0C8D:  MOVWF  2E
....................    RF_DATA[1] = 100; 
0C8E:  MOVWF  2F
....................    RF_DATA[2] = 100; 
0C8F:  MOVWF  30
....................    RF_DATA[3] = 100; 
0C90:  MOVWF  31
....................    RF_DIR=0x01;           // Dirección del receptor. 
0C91:  MOVLW  01
0C92:  MOVWF  36
....................    ret2=RF_SEND();        // Enviar datos. 
0C93:  CALL   000
0C94:  MOVF   78,W
0C95:  MOVWF  60
....................    delay_ms(3000); 
0C96:  MOVLW  0C
0C97:  MOVWF  67
0C98:  MOVLW  FA
0C99:  MOVWF  68
0C9A:  BCF    0A.3
0C9B:  CALL   5D1
0C9C:  BSF    0A.3
0C9D:  DECFSZ 67,F
0C9E:  GOTO   498
....................    Dato1 = buffer[0]; 
0C9F:  MOVF   40,W
0CA0:  MOVWF  3A
....................    Bat_lvl = (Dato1/256.0)*10.0; 
0CA1:  CLRF   68
0CA2:  MOVF   3A,W
0CA3:  MOVWF  67
0CA4:  BCF    0A.3
0CA5:  CALL   7BC
0CA6:  BSF    0A.3
0CA7:  MOVF   7A,W
0CA8:  MOVWF  6A
0CA9:  MOVF   79,W
0CAA:  MOVWF  69
0CAB:  MOVF   78,W
0CAC:  MOVWF  68
0CAD:  MOVF   77,W
0CAE:  MOVWF  67
0CAF:  CLRF   6E
0CB0:  CLRF   6D
0CB1:  CLRF   6C
0CB2:  MOVLW  87
0CB3:  MOVWF  6B
0CB4:  CALL   1E2
0CB5:  MOVF   77,W
0CB6:  MOVWF  67
0CB7:  MOVF   78,W
0CB8:  MOVWF  68
0CB9:  MOVF   79,W
0CBA:  MOVWF  69
0CBB:  MOVF   7A,W
0CBC:  MOVWF  6A
0CBD:  BSF    03.5
0CBE:  MOVWF  23
0CBF:  BCF    03.5
0CC0:  MOVF   79,W
0CC1:  BSF    03.5
0CC2:  MOVWF  22
0CC3:  BCF    03.5
0CC4:  MOVF   78,W
0CC5:  BSF    03.5
0CC6:  MOVWF  21
0CC7:  BCF    03.5
0CC8:  MOVF   77,W
0CC9:  BSF    03.5
0CCA:  MOVWF  20
0CCB:  CLRF   27
0CCC:  CLRF   26
0CCD:  MOVLW  20
0CCE:  MOVWF  25
0CCF:  MOVLW  82
0CD0:  MOVWF  24
0CD1:  BCF    03.5
0CD2:  CALL   2AC
0CD3:  MOVF   7A,W
0CD4:  MOVWF  3E
0CD5:  MOVF   79,W
0CD6:  MOVWF  3D
0CD7:  MOVF   78,W
0CD8:  MOVWF  3C
0CD9:  MOVF   77,W
0CDA:  MOVWF  3B
....................    temperatura = buffer[3]; 
0CDB:  CLRF   68
0CDC:  MOVF   43,W
0CDD:  MOVWF  67
0CDE:  BCF    0A.3
0CDF:  CALL   7BC
0CE0:  BSF    0A.3
0CE1:  MOVF   7A,W
0CE2:  MOVWF  64
0CE3:  MOVF   79,W
0CE4:  MOVWF  63
0CE5:  MOVF   78,W
0CE6:  MOVWF  62
0CE7:  MOVF   77,W
0CE8:  MOVWF  61
....................    temperatura = (temperatura*(5.0/256.0)); 
0CE9:  MOVF   64,W
0CEA:  BSF    03.5
0CEB:  MOVWF  23
0CEC:  BCF    03.5
0CED:  MOVF   63,W
0CEE:  BSF    03.5
0CEF:  MOVWF  22
0CF0:  BCF    03.5
0CF1:  MOVF   62,W
0CF2:  BSF    03.5
0CF3:  MOVWF  21
0CF4:  BCF    03.5
0CF5:  MOVF   61,W
0CF6:  BSF    03.5
0CF7:  MOVWF  20
0CF8:  CLRF   27
0CF9:  CLRF   26
0CFA:  MOVLW  20
0CFB:  MOVWF  25
0CFC:  MOVLW  79
0CFD:  MOVWF  24
0CFE:  BCF    03.5
0CFF:  CALL   2AC
0D00:  MOVF   7A,W
0D01:  MOVWF  64
0D02:  MOVF   79,W
0D03:  MOVWF  63
0D04:  MOVF   78,W
0D05:  MOVWF  62
0D06:  MOVF   77,W
0D07:  MOVWF  61
....................    temperatura = temperatura - 0.5; 
0D08:  BSF    03.1
0D09:  MOVF   64,W
0D0A:  MOVWF  6A
0D0B:  MOVF   63,W
0D0C:  MOVWF  69
0D0D:  MOVF   62,W
0D0E:  MOVWF  68
0D0F:  MOVF   61,W
0D10:  MOVWF  67
0D11:  CLRF   6E
0D12:  CLRF   6D
0D13:  CLRF   6C
0D14:  MOVLW  7E
0D15:  MOVWF  6B
*
0E56:  MOVF   7A,W
0E57:  MOVWF  64
0E58:  MOVF   79,W
0E59:  MOVWF  63
0E5A:  MOVF   78,W
0E5B:  MOVWF  62
0E5C:  MOVF   77,W
0E5D:  MOVWF  61
....................    temperatura = temperatura/0.01; 
0E5E:  MOVF   64,W
0E5F:  MOVWF  6A
0E60:  MOVF   63,W
0E61:  MOVWF  69
0E62:  MOVF   62,W
0E63:  MOVWF  68
0E64:  MOVF   61,W
0E65:  MOVWF  67
0E66:  MOVLW  0A
0E67:  MOVWF  6E
0E68:  MOVLW  D7
0E69:  MOVWF  6D
0E6A:  MOVLW  23
0E6B:  MOVWF  6C
0E6C:  MOVLW  78
0E6D:  MOVWF  6B
0E6E:  CALL   1E2
0E6F:  MOVF   7A,W
0E70:  MOVWF  64
0E71:  MOVF   79,W
0E72:  MOVWF  63
0E73:  MOVF   78,W
0E74:  MOVWF  62
0E75:  MOVF   77,W
0E76:  MOVWF  61
....................    // Devuelvo el valor por cada linea. 
....................    printf("%2.2f \r\n ",temperatura); 
0E77:  MOVLW  89
0E78:  MOVWF  04
0E79:  MOVF   64,W
0E7A:  MOVWF  6A
0E7B:  MOVF   63,W
0E7C:  MOVWF  69
0E7D:  MOVF   62,W
0E7E:  MOVWF  68
0E7F:  MOVF   61,W
0E80:  MOVWF  67
0E81:  MOVLW  02
0E82:  MOVWF  6B
0E83:  GOTO   367
0E84:  MOVLW  05
0E85:  MOVWF  67
0E86:  MOVF   67,W
0E87:  BCF    0A.3
0E88:  CALL   11E
0E89:  BSF    0A.3
0E8A:  INCF   67,F
0E8B:  MOVWF  77
0E8C:  MOVF   77,W
0E8D:  BTFSS  0C.4
0E8E:  GOTO   68D
0E8F:  MOVWF  19
0E90:  MOVLW  09
0E91:  SUBWF  67,W
0E92:  BTFSS  03.2
0E93:  GOTO   686
....................    delay_ms(5000); 
0E94:  MOVLW  14
0E95:  MOVWF  67
0E96:  MOVLW  FA
0E97:  MOVWF  68
0E98:  BCF    0A.3
0E99:  CALL   5D1
0E9A:  BSF    0A.3
0E9B:  DECFSZ 67,F
0E9C:  GOTO   696
....................    } 
0E9D:  GOTO   48C
.................... } 
0E9E:  BCF    0A.3
0E9F:  BSF    0A.4
0EA0:  GOTO   140 (RETURN)
....................  
.................... // Test de frame. Impresion por pantalla. 
.................... void modo_4(){ 
....................       //float f=561.234567; 
....................      // int in=134; 
....................      // char s2[20]; 
....................      // char s[20]; 
....................      // int longitud; 
....................        
....................       int j; 
....................       int g; 
....................       printf("---- Pulsado 4---- \r\n");     
0EA1:  CLRF   6A
0EA2:  MOVF   6A,W
0EA3:  BCF    0A.3
0EA4:  CALL   12C
0EA5:  BSF    0A.3
0EA6:  INCF   6A,F
0EA7:  MOVWF  77
0EA8:  MOVF   77,W
0EA9:  BTFSS  0C.4
0EAA:  GOTO   6A9
0EAB:  MOVWF  19
0EAC:  MOVLW  15
0EAD:  SUBWF  6A,W
0EAE:  BTFSS  03.2
0EAF:  GOTO   6A2
....................      // Generamos un frame de numeros. 
....................      for (g=0;g<24;g++) 
0EB0:  CLRF   68
0EB1:  MOVF   68,W
0EB2:  SUBLW  17
0EB3:  BTFSS  03.0
0EB4:  GOTO   6C6
....................          { 
....................          int h; 
....................          for (h=0;h<8;h++) 
0EB5:  CLRF   69
0EB6:  MOVF   69,W
0EB7:  SUBLW  07
0EB8:  BTFSS  03.0
0EB9:  GOTO   6C3
....................             { 
....................             Buff[g] = h; 
0EBA:  MOVLW  48
0EBB:  ADDWF  68,W
0EBC:  MOVWF  04
0EBD:  BCF    03.7
0EBE:  MOVF   69,W
0EBF:  MOVWF  00
....................             g++; 
0EC0:  INCF   68,F
....................             }  
0EC1:  INCF   69,F
0EC2:  GOTO   6B6
....................           g--;   
0EC3:  DECF   68,F
....................          } 
0EC4:  INCF   68,F
0EC5:  GOTO   6B1
....................       printf("Frame Buffer: ");    
0EC6:  CLRF   6A
0EC7:  MOVF   6A,W
0EC8:  BCF    0A.3
0EC9:  CALL   146
0ECA:  BSF    0A.3
0ECB:  INCF   6A,F
0ECC:  MOVWF  77
0ECD:  MOVF   77,W
0ECE:  BTFSS  0C.4
0ECF:  GOTO   6CE
0ED0:  MOVWF  19
0ED1:  MOVLW  0E
0ED2:  SUBWF  6A,W
0ED3:  BTFSS  03.2
0ED4:  GOTO   6C7
....................     for (j=0;j<24;j++){ 
0ED5:  CLRF   67
0ED6:  MOVF   67,W
0ED7:  SUBLW  17
0ED8:  BTFSS  03.0
0ED9:  GOTO   6E8
....................          printf("%D", Buff[j]);      
0EDA:  MOVLW  48
0EDB:  ADDWF  67,W
0EDC:  MOVWF  04
0EDD:  BCF    03.7
0EDE:  MOVF   00,W
0EDF:  MOVWF  6A
0EE0:  MOVWF  6B
0EE1:  MOVLW  1F
0EE2:  MOVWF  6C
0EE3:  BCF    0A.3
0EE4:  CALL   62C
0EE5:  BSF    0A.3
....................      
....................     } 
0EE6:  INCF   67,F
0EE7:  GOTO   6D6
....................     /* 
....................     printf(" \r\n "); 
....................      
....................      
....................     sprintf(s,"%3.4f",f); 
....................     printf("%s",s); 
....................     printf(" \r\n "); 
....................      
....................     printf("en int: %U", in);  
....................     printf(" \r\n "); 
....................     printf("en int - string: %s", in); 
....................     printf(" \r\n "); 
....................     sprintf(s2,"%U",in); 
....................     printf("%s",s2); 
....................     printf(" \r\n "); 
....................      
....................  
....................    longitud = strlen(s); 
....................    printf( "La cadena \"%s\" tiene %i caracteres.\n", s, longitud ); 
....................    */ 
.................... } 
0EE8:  BCF    0A.3
0EE9:  BSF    0A.4
0EEA:  GOTO   140 (RETURN)
....................  
.................... void Modo_escucha(){ 
....................    printf("(6)- Modo Escucha \r\n" ); 
0EEB:  CLRF   67
0EEC:  MOVF   67,W
0EED:  BCF    0A.3
0EEE:  CALL   159
0EEF:  BSF    0A.3
0EF0:  INCF   67,F
0EF1:  MOVWF  77
0EF2:  MOVF   77,W
0EF3:  BTFSS  0C.4
0EF4:  GOTO   6F3
0EF5:  MOVWF  19
0EF6:  MOVLW  14
0EF7:  SUBWF  67,W
0EF8:  BTFSS  03.2
0EF9:  GOTO   6EC
....................    RF_DATA[3] = 100; 
0EFA:  MOVLW  64
0EFB:  MOVWF  31
....................    RF_DIR=0x01;           // Dirección del receptor. 
0EFC:  MOVLW  01
0EFD:  MOVWF  36
....................    ret2=RF_SEND();        // Enviar datos. 
0EFE:  CALL   000
0EFF:  MOVF   78,W
0F00:  MOVWF  60
....................    delay_ms(200); 
0F01:  MOVLW  C8
0F02:  MOVWF  68
0F03:  BCF    0A.3
0F04:  CALL   5D1
0F05:  BSF    0A.3
....................    while(1){ 
....................       output_high(PIN_C0); 
0F06:  BCF    37.0
0F07:  MOVF   37,W
0F08:  BSF    03.5
0F09:  MOVWF  07
0F0A:  BCF    03.5
0F0B:  BSF    07.0
....................       delay_ms(1000); 
0F0C:  MOVLW  04
0F0D:  MOVWF  67
0F0E:  MOVLW  FA
0F0F:  MOVWF  68
0F10:  BCF    0A.3
0F11:  CALL   5D1
0F12:  BSF    0A.3
0F13:  DECFSZ 67,F
0F14:  GOTO   70E
....................       output_low(PIN_C0); 
0F15:  BCF    37.0
0F16:  MOVF   37,W
0F17:  BSF    03.5
0F18:  MOVWF  07
0F19:  BCF    03.5
0F1A:  BCF    07.0
....................       delay_ms(1000); 
0F1B:  MOVLW  04
0F1C:  MOVWF  67
0F1D:  MOVLW  FA
0F1E:  MOVWF  68
0F1F:  BCF    0A.3
0F20:  CALL   5D1
0F21:  BSF    0A.3
0F22:  DECFSZ 67,F
0F23:  GOTO   71D
....................    } 
0F24:  GOTO   706
....................   } 
0F25:  BCF    0A.3
0F26:  BSF    0A.4
0F27:  GOTO   140 (RETURN)
....................  
.................... void modo_continuo(){ 
.................... // Modo continuo, sin salida. Solicita al mote cada X segundos su estado. 
....................     
....................    while(1){ 
....................        printf("---- Pulsado 5 - Modo Continuo v0.1 ---- \r\n"); 
*
0786:  CLRF   67
0787:  MOVF   67,W
0788:  CALL   172
0789:  INCF   67,F
078A:  MOVWF  77
078B:  MOVF   77,W
078C:  BTFSS  0C.4
078D:  GOTO   78C
078E:  MOVWF  19
078F:  MOVLW  2B
0790:  SUBWF  67,W
0791:  BTFSS  03.2
0792:  GOTO   787
....................        printf("  Contador: %D \r\n",count); 
0793:  CLRF   67
0794:  MOVF   67,W
0795:  CALL   1A2
0796:  INCF   67,F
0797:  MOVWF  77
0798:  MOVF   77,W
0799:  BTFSS  0C.4
079A:  GOTO   799
079B:  MOVWF  19
079C:  MOVLW  0C
079D:  SUBWF  67,W
079E:  BTFSS  03.2
079F:  GOTO   794
07A0:  MOVF   65,W
07A1:  MOVWF  6B
07A2:  MOVLW  1F
07A3:  MOVWF  6C
07A4:  CALL   62C
07A5:  MOVLW  20
07A6:  BTFSS  0C.4
07A7:  GOTO   7A6
07A8:  MOVWF  19
07A9:  MOVLW  0D
07AA:  BTFSS  0C.4
07AB:  GOTO   7AA
07AC:  MOVWF  19
07AD:  MOVLW  0A
07AE:  BTFSS  0C.4
07AF:  GOTO   7AE
07B0:  MOVWF  19
....................        count++; 
07B1:  INCF   65,F
....................        Mote1(); 
07B2:  CALL   695
....................        delay_ms(5000); 
07B3:  MOVLW  14
07B4:  MOVWF  67
07B5:  MOVLW  FA
07B6:  MOVWF  68
07B7:  CALL   5D1
07B8:  DECFSZ 67,F
07B9:  GOTO   7B5
....................    } 
07BA:  GOTO   786
.................... } 
07BB:  RETLW  00
....................  
.................... void main()                  //Programa principal 
.................... { 
*
1000:  CLRF   04
1001:  BCF    03.7
1002:  MOVLW  1F
1003:  ANDWF  03,F
1004:  MOVLW  19
1005:  BSF    03.5
1006:  MOVWF  19
1007:  MOVLW  A6
1008:  MOVWF  18
1009:  MOVLW  90
100A:  BCF    03.5
100B:  MOVWF  18
100C:  BSF    03.5
100D:  BSF    1F.0
100E:  BSF    1F.1
100F:  BSF    1F.2
1010:  BCF    1F.3
1011:  MOVLW  07
1012:  MOVWF  1C
....................    set_tris_a(0b000000);     // Todo el puerto A como salida. 
*
1032:  MOVLW  00
1033:  BSF    03.5
1034:  MOVWF  05
....................    porta=0;                  // Inicialmente lo ponemos a cero. 
1035:  BCF    03.5
1036:  CLRF   05
....................   // output_high(PIN_B2);      // ON/OFF Consumo modulo de comunicacion.    
....................    RF_INT_EN();              // Habilitar interrupción RB0/INT. 
1037:  BCF    0A.4
1038:  GOTO   3DA
1039:  BSF    0A.4
....................    RF_CONFIG_SPI();          // Configurar módulos SPI del PIC. 
103A:  BCF    0A.4
103B:  GOTO   3E8
103C:  BSF    0A.4
....................    RF_CONFIG(0x40,0x08);     // Configurar módulo RF (canal y dirección). 
103D:  MOVLW  40
103E:  MOVWF  67
103F:  MOVLW  08
1040:  MOVWF  68
1041:  BCF    0A.4
1042:  GOTO   406
1043:  BSF    0A.4
....................    RF_ON();                  // Activar el módulo RF. 
1044:  BCF    0A.4
1045:  GOTO   5E6
1046:  BSF    0A.4
....................     
....................     
....................    printf("Receptor listo:"); 
1047:  CLRF   67
1048:  MOVF   67,W
1049:  BCF    0A.4
104A:  CALL   1B8
104B:  BSF    0A.4
104C:  INCF   67,F
104D:  MOVWF  77
104E:  MOVF   77,W
104F:  BTFSS  0C.4
1050:  GOTO   04F
1051:  MOVWF  19
1052:  MOVLW  0F
1053:  SUBWF  67,W
1054:  BTFSS  03.2
1055:  GOTO   048
....................     
....................    while(1) // Bucle infinito. 
....................        { 
....................         
....................        printf("\r\n" ); 
1056:  MOVLW  0D
1057:  BTFSS  0C.4
1058:  GOTO   057
1059:  MOVWF  19
105A:  MOVLW  0A
105B:  BTFSS  0C.4
105C:  GOTO   05B
105D:  MOVWF  19
....................        printf("\r\n" ); 
105E:  MOVLW  0D
105F:  BTFSS  0C.4
1060:  GOTO   05F
1061:  MOVWF  19
1062:  MOVLW  0A
1063:  BTFSS  0C.4
1064:  GOTO   063
1065:  MOVWF  19
....................        printf("Firm SL-Air Mote_Master Beta 0.02\r\n"); 
1066:  CLRF   67
1067:  MOVF   67,W
1068:  BCF    0A.4
1069:  CALL   1CC
106A:  BSF    0A.4
106B:  INCF   67,F
106C:  MOVWF  77
106D:  MOVF   77,W
106E:  BTFSS  0C.4
106F:  GOTO   06E
1070:  MOVWF  19
1071:  MOVLW  23
1072:  SUBWF  67,W
1073:  BTFSS  03.2
1074:  GOTO   067
....................        printf("--- Menu ---\r\n"); 
1075:  CLRF   67
1076:  MOVF   67,W
1077:  BCF    0A.4
1078:  CALL   1F4
1079:  BSF    0A.4
107A:  INCF   67,F
107B:  MOVWF  77
107C:  MOVF   77,W
107D:  BTFSS  0C.4
107E:  GOTO   07D
107F:  MOVWF  19
1080:  MOVLW  0E
1081:  SUBWF  67,W
1082:  BTFSS  03.2
1083:  GOTO   076
....................        printf("Canal;Direccion Master...: 0x40;0x08 \r\n"); 
1084:  CLRF   67
1085:  MOVF   67,W
1086:  BCF    0A.4
1087:  CALL   20A
1088:  BSF    0A.4
1089:  INCF   67,F
108A:  MOVWF  77
108B:  MOVF   77,W
108C:  BTFSS  0C.4
108D:  GOTO   08C
108E:  MOVWF  19
108F:  MOVLW  27
1090:  SUBWF  67,W
1091:  BTFSS  03.2
1092:  GOTO   085
....................        printf("(1)- Estado Mote 1 \r\n" ); 
1093:  CLRF   67
1094:  MOVF   67,W
1095:  BCF    0A.4
1096:  CALL   236
1097:  BSF    0A.4
1098:  INCF   67,F
1099:  MOVWF  77
109A:  MOVF   77,W
109B:  BTFSS  0C.4
109C:  GOTO   09B
109D:  MOVWF  19
109E:  MOVLW  15
109F:  SUBWF  67,W
10A0:  BTFSS  03.2
10A1:  GOTO   094
....................        printf("(3)- Modo grabar datos \r\n" ); 
10A2:  CLRF   67
10A3:  MOVF   67,W
10A4:  BCF    0A.4
10A5:  CALL   250
10A6:  BSF    0A.4
10A7:  INCF   67,F
10A8:  MOVWF  77
10A9:  MOVF   77,W
10AA:  BTFSS  0C.4
10AB:  GOTO   0AA
10AC:  MOVWF  19
10AD:  MOVLW  19
10AE:  SUBWF  67,W
10AF:  BTFSS  03.2
10B0:  GOTO   0A3
....................        printf("(4)- Test Buffer Frame \r\n" ); 
10B1:  CLRF   67
10B2:  MOVF   67,W
10B3:  BCF    0A.4
10B4:  CALL   26E
10B5:  BSF    0A.4
10B6:  INCF   67,F
10B7:  MOVWF  77
10B8:  MOVF   77,W
10B9:  BTFSS  0C.4
10BA:  GOTO   0B9
10BB:  MOVWF  19
10BC:  MOVLW  19
10BD:  SUBWF  67,W
10BE:  BTFSS  03.2
10BF:  GOTO   0B2
....................        printf("(5)- Modo Continuo v0.1 \r\n" ); 
10C0:  CLRF   67
10C1:  MOVF   67,W
10C2:  BCF    0A.4
10C3:  CALL   28C
10C4:  BSF    0A.4
10C5:  INCF   67,F
10C6:  MOVWF  77
10C7:  MOVF   77,W
10C8:  BTFSS  0C.4
10C9:  GOTO   0C8
10CA:  MOVWF  19
10CB:  MOVLW  1A
10CC:  SUBWF  67,W
10CD:  BTFSS  03.2
10CE:  GOTO   0C1
....................        printf("(6)- Modo Escucha \r\n" ); 
10CF:  CLRF   67
10D0:  MOVF   67,W
10D1:  BCF    0A.4
10D2:  CALL   159
10D3:  BSF    0A.4
10D4:  INCF   67,F
10D5:  MOVWF  77
10D6:  MOVF   77,W
10D7:  BTFSS  0C.4
10D8:  GOTO   0D7
10D9:  MOVWF  19
10DA:  MOVLW  14
10DB:  SUBWF  67,W
10DC:  BTFSS  03.2
10DD:  GOTO   0D0
....................         
....................       //RF_OFF(); 
....................        opcion = getc(); 
10DE:  BTFSS  0C.5
10DF:  GOTO   0DE
10E0:  MOVF   1A,W
10E1:  MOVWF  3F
....................          switch(opcion){ 
10E2:  MOVF   3F,W
10E3:  XORLW  20
10E4:  BTFSC  03.2
10E5:  GOTO   0FC
10E6:  XORLW  10
10E7:  BTFSC  03.2
10E8:  GOTO   10C
10E9:  XORLW  01
10EA:  BTFSC  03.2
10EB:  GOTO   110
10EC:  XORLW  03
10ED:  BTFSC  03.2
10EE:  GOTO   114
10EF:  XORLW  01
10F0:  BTFSC  03.2
10F1:  GOTO   119
10F2:  XORLW  07
10F3:  BTFSC  03.2
10F4:  GOTO   129
10F5:  XORLW  01
10F6:  BTFSC  03.2
10F7:  GOTO   12E
10F8:  XORLW  03
10F9:  BTFSC  03.2
10FA:  GOTO   132
10FB:  GOTO   140
....................          case ' ': printf("---- Pulsado espacio ---- \r\n"); 
10FC:  CLRF   67
10FD:  MOVF   67,W
10FE:  BCF    0A.4
10FF:  CALL   2AB
1100:  BSF    0A.4
1101:  INCF   67,F
1102:  MOVWF  77
1103:  MOVF   77,W
1104:  BTFSS  0C.4
1105:  GOTO   104
1106:  MOVWF  19
1107:  MOVLW  1C
1108:  SUBWF  67,W
1109:  BTFSS  03.2
110A:  GOTO   0FD
....................          break; 
110B:  GOTO   140
....................          case '0': modo_continuo(); 
110C:  BCF    0A.4
110D:  CALL   786
110E:  BSF    0A.4
....................          break;        
110F:  GOTO   140
....................          case '1': Mote1(); 
1110:  BCF    0A.4
1111:  CALL   695
1112:  BSF    0A.4
....................          break; 
1113:  GOTO   140
....................          case '2': modo_2();          
1114:  BCF    0A.4
1115:  BSF    0A.3
1116:  GOTO   46E
1117:  BSF    0A.4
1118:  BCF    0A.3
....................          break; 
....................          case '3': printf("---- Pulsado 3---- \r\n"); 
1119:  CLRF   67
111A:  MOVF   67,W
111B:  BCF    0A.4
111C:  CALL   2CC
111D:  BSF    0A.4
111E:  INCF   67,F
111F:  MOVWF  77
1120:  MOVF   77,W
1121:  BTFSS  0C.4
1122:  GOTO   121
1123:  MOVWF  19
1124:  MOVLW  15
1125:  SUBWF  67,W
1126:  BTFSS  03.2
1127:  GOTO   11A
....................          break; 
1128:  GOTO   140
....................          case '4': modo_4(); 
1129:  BCF    0A.4
112A:  BSF    0A.3
112B:  GOTO   6A1
112C:  BSF    0A.4
112D:  BCF    0A.3
....................          break; 
....................          case '5': modo_continuo(); 
112E:  BCF    0A.4
112F:  CALL   786
1130:  BSF    0A.4
....................          break; 
1131:  GOTO   140
....................          case '6': Modo_escucha(); 
1132:  BCF    0A.4
1133:  BSF    0A.3
1134:  GOTO   6EB
1135:  BSF    0A.4
1136:  BCF    0A.3
....................          break; 
....................        delay_ms(1000); 
1137:  MOVLW  04
1138:  MOVWF  67
1139:  MOVLW  FA
113A:  MOVWF  68
113B:  BCF    0A.4
113C:  CALL   5D1
113D:  BSF    0A.4
113E:  DECFSZ 67,F
113F:  GOTO   139
....................             
....................        } 
.................... } 
1140:  GOTO   056
.................... } 
....................  
1141:  SLEEP

Configuration Fuses:
   Word  1: 3F31   XT NOWDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
